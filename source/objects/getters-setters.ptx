<section xml:id="objects_setters-getters"
         xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Getters and Setters</title>

    <p>In the previous section, we saw how to provide access to private member variables through a public member functions. That is a common pattern: for any variable we want to provide access to, we provide <term>getter</term> function. A <term>getter</term> or <term>accessor</term> is a function that just returns the value of a member variable. </p>

    <p>If we want to provide the ability for outside code to modify a member variable, we can add a <term>
      setter</term> function. These are functions that take a value and use that to set a member
      variable. This version of the Point class adds a setter for <pf>m_x</pf>:</p>

    <listing>
    <program label="objects_getters-setters-program-2"
             interactive="codelens">
<xi:include href="../../programs/objects/getters-setters-2.cpp" parse="text"/>
</program>
</listing>

    <p>When main calls <pf>p1.setX(5.0)</pf>, it passes in the value 5. The <pf>Point::setX(double x)</pf> function takes that parameter and assigns the value into the <pf>m_x</pf> member variable of <pf>p1</pf>.</p>

    <p>As with getters, setters provide a limited way for outside code to manipulate the object.
      Outside code can't directly change <pf>m_x</pf>, it has to use the interface to ask a given point to
      please make the change to itself. This means the class can <q>protect itself</q> from unsafe or unwanted changes.</p>

    <p>Say you are creating a Person class and you want to make sure that the age of a person never
      gets set to a negative value. You could design the class to prevent that from happening:</p>

    <listing>
    <program label="objects_getters-setters-program-3"
    line-numbers="yes"
    highlight-lines="17-23, 33, 36"
             interactive="activecode">
<xi:include href="../../programs/objects/getters-setters-3.cpp" parse="text"/>
</program>
    </listing>

    <p>When main tries to set a negative age, the <pf>Person</pf> class ignores that request and
      prints an error message. (In a real program we might throw an exception.) 
    </p>

    <insight>
      <p>Remember the <q>two programmers</q> tip for understanding Object Oriented Programming.</p>

      <p>The person programming <pf>Person</pf> is the expert who knows all the important ins and outs of
        the Person class. They know that a negative value is going to cause problems later. The
        person programming main does not realize that issue even exists. If they could set `p1.m_age
        = -5;` directly, they could end up causing the program to do something horrible later on.</p>

      <p>By forcing others to use the public interface and then preventing unwanted modifications in
        that interface, the programmer of the Point class is able to limit the potential for such
        issues.</p>

      <p>When looking at a simple code example. Or when you are writing a small program and know and are responsible for all of the code, much of what we do in object-oriented
        programming may seem unnecessary. But in a large project, especially one with many programmers, these kinds
        of protections can be very valuable.
      </p>
    </insight>

    <p>
      This structure also gives the programmer of the Person class the freedom to change how age is stored
      internally without breaking outside code. Maybe in the future we change the class to store
      the birthdate instead of the age. As long as we keep the same public interface with
      <pf>getAge()</pf> and <pf>setAge(int age)</pf>, outside code will not be affected by that change.
    </p>

    <p>Setters are a special kind of <term>mutator</term> function. A mutator is any function that
      changes the state of an object. While a <term>setter</term> sets a member to a particular
      value, another kind of mutator might set more than one value or change a variable in a way
      that doesn't allow outside code to set a particular value.<idx>
        <h>mutator</h>
      </idx></p>

    <p>For instance, a person might have a <pf>void getOlder()</pf> function that looked like:</p>
    <listing>
    <program>
class Person {
private:
    int m_age;
public:
    void getOlder() {
        m_age++;
    }
    ...
    </program>
    </listing>

    <p><pf>getOlder</pf> mutates (changes) the object. But it doesn't allow other code to change the age to
      an arbitrary value.</p>

  <exercise label="objects_getters-setters-ex-2"
            numbered="yes"
            adaptive="yes"
            indentation="show">
    <statement>
      <p>In <pf>main</pf> we want to create a <pf>Circle</pf>, set the radius to 2.4 and output the radius. Then change
        the radius to 3.6 and output the new radius. We want to use the public interface of the
        Circle class and not depend on the private details of the class.</p>
      <p>Put the correct blocks of code in the correct order.</p>
    </statement>
    <blocks>
      <block>
        <cline>int main() {</cline>
      </block>
      <block>
        <cline> Circle c;</cline>
      </block>
      <block>
        <cline> c.setRadius(2.4);</cline>
      </block>
      <block correct="no">
        <cline> c.m_radius = 2.4;  </cline>
      </block>
      <block>
        <cline><![CDATA[ cout << "Radius: " << c.getRadius() << endl;]]></cline>
      </block>
      <block correct="no">
        <cline><![CDATA[ cout << "Radius: " << c.m_radius << endl;  ]]></cline>
      </block>
      <block correct="no">
        <cline> c.m_radius = 3.6;  </cline>
      </block>
      <block>
        <cline> s.setRadius(3.6);</cline>
      </block>
      <block>
        <cline><![CDATA[ cout << "New radius: " << c.getRadius() << endl;]]></cline>
      </block>
      <block correct="no">
        <cline><![CDATA[ cout << "New radius: " << c.m_radius << endl;  ]]></cline>
      </block>
      <block>
        <cline>}</cline>
      </block>
    </blocks>
  </exercise>
</section>