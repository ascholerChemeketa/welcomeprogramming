<section xml:id="objects_member-access"
         xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Member Functions</title>

  <p>If we make the member variables of a class <pf>private</pf>, they are part of its <term>implementation</term>
    and outside code cannot access them directly. So how can outside code get or set the values of
    those member variables?</p>

  <p>To allow for that, we need to provide an <term>interface</term> through which outside code can access those
    member variables. We do this by declaring <term>member functions</term> (also sometimes called <term>methods</term>) that are part of the class and have access
    to the private member variables. We then make those functions <pf>public</pf> so that outside code can call them.
    <idx>
      <h>member functions</h>
    </idx>   <idx>
      <h>methods</h>
    </idx></p>

    <listing>
    <program line-numbers="yes" highlight-lines="4-7">
class Point {
// Interface
// public member functions
public:
    double getX() {
        return m_x;
    }

// Implementation
// private member variables
private:
    double m_x;
    double m_y;
}
  </program>
    </listing>

    <p>Note that the function <pf>getX</pf> is in a <pf>public</pf> block. Then look closely at the code inside the function <pf>getX()</pf>. What looks odd?</p>

    <p>There is no declaration of <pf>m_x</pf> in this function! It is not declared as a
      parameter, nor is it declared as a local variable. 
      It is the member variable of Point named <pf>m_x</pf>. <pf>getX</pf> is a part of a <pf>Point</pf> object, and every object has a <pf>m_x</pf>, so it is assumed that <pf>m_x</pf> refers to the member variable of <q>the current object</q>.</p>

    <insight>
      <p>Inside member functions, we always have
      access to the member variables of the object, even if they are private.</p>
    </insight>

    <p>To call a member function, we always need to call it on a particular object:</p>

    <program>
p1.getX();
p2.getX();
</program>

    <p>Trying to use a member function without an object is a syntax error. There is no <pf>getX()</pf>
      function, there is only the <pf>getX()</pf> function that is a member of the <pf>Point</pf> class.
      (<pf>Point::getX()</pf> is the full name of this function - <q>the getX that is a part of Point</q>.)</p>

    <p>The fact that we call the function on a particular Point is what allows the function to know which object's <pf>m_x</pf> to return.</p>

    <p>Run this Codelens sample. You can ignore the code on lines 8-11 for now. But pay special attention each time it enters the <pf>getX</pf> function. When it does so, you
      will see a stack frame for <pf>Point::getX()</pf> and in that stack frame, you will see a variable
      called <pf>this</pf> that points at the object that is running the code. During the first call to
      <pf>Point::getX()</pf>, it will point to <pf>p1</pf> since we called <pf>p1.getX()</pf> on line 23. Then, on line
      26 when we call <pf>p2.getX()</pf>, <pf>this</pf> will be pointing at <pf>p2</pf>.</p>

    <listing>
    <program label="objects_member-access-program-1"
             interactive="codelens">
<xi:include href="../../programs/objects/member-access-1.cpp" parse="text"/>
</program>
    </listing>

    <p>A hand drawn memory diagram might look like this:</p>

    <figure align="center">
      <caption>A memory diagram of p1 executing getX</caption>
      <image source="images/objects-this.svg"
            width="50%"
            >
        <shortdescription>When getX is called on p1, this refers to p1</shortdescription>
      </image>
    </figure>

    <note>
      <p>We will learn more about exactly what <pf>this</pf> is in <xref ref="pointers-aggregation_this"/>. For now, you can think of it as an
        alias for <q>the object running the code</q>. When we say <pf>m_x</pf> in a member function, it is
        understood to mean <pf>this->m_x</pf> or <q>the <pf>m_x</pf> variable of the object running this code</q>.</p>
    </note>

    <p>The code in main is not allowed to directly access the private member variable <pf>m_x</pf> of the Point. But it can politely ask the Point to give it the value by calling a public member function <pf>getX()</pf>. The <pf>getX()</pf> function, as a member of the class, has access to the private information. Thus, we are providing an interface (public functions) so outside code can interact with the implementation (private variables) in a controlled way.</p>

  <insight>
    <p>A good rule of thumb is that member variables should be private and member functions public.</p>
    <p>There will be rare exceptions:
    <ul>
      <li>A constant variable might reasonably be made public - there is no way for outside code to use it to change the state of the object.</li>
      <li>There might be a function that is a useful helper to other member functions but makes no sense for outside code to use. That function could be marked private to prevent its use from outside the class.</li>
    </ul>
    But unless you have a very good reason, stick the the rule of thumb.
    </p>
  </insight>

    <p>Currently, the interface does not allow outside code to change the <pf>m_x</pf> variable. From main, we can call <pf>getX()</pf> but there is no public member function that allows us to change it.</p>

    
  <exercise label="objects_member-access-ex-1">
    <statement>
      <p>Which of the following appear to be accessor functions based on their name?</p>
    </statement>
    <choices randomize="yes">
      <choice correct="yes">
        <statement>
          <p>getSuit</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>setRank</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>print</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>getRank</p>
        </statement>
      </choice>
    </choices>
  </exercise>

    <exercise label="objects_member-access-ex-2">
      <statement>
        <p>Examine this code. Then decide what best describes the meaning of <pf>m_red</pf> on line 6. </p>
        <program line-numbers="yes">
        class Color {
        private:
            int m_red, m_green, m_blue;
        public:
            int getRed() {
                return m_red;
            }
        };

        int main() {
            Color c1;
            Color c2;
            c1.getRed();
        }
      </program>
      </statement>
      <choices randomize="yes">
        <choice correct="yes">
          <statement>
            <p> The <pf>m_red</pf> value of whatever Color object getRed() was called on</p>
          </statement>
        </choice>
        <choice>
          <statement>
            <p> The <pf>m_red</pf> value of <pf>c1</pf>. </p>
          </statement>
          <feedback> Although we only currently use getRed on <pf>c1</pf>, it is possible that we could
            later call it on <pf>c2</pf>. So <pf>m_red</pf> is not guaranteed to be the value of <pf>c1</pf>. </feedback>
        </choice>
        <choice>
          <statement>
            <p> The <pf>m_red</pf> value of <pf>c2</pf>. </p>
          </statement>
          <feedback> We are not using <pf>c2</pf>. </feedback>
        </choice>
        <choice>
          <statement>
            <p> The <pf>m_red</pf> value of the Color class. </p>
          </statement>
          <feedback> The class itself does not have a <pf>m_red</pf> value. The class is just a blueprint
            for creating objects. The <pf>m_red</pf> variable is a member of each instance of the class. </feedback>
        </choice>
      </choices>
    </exercise>


</section>