<section xml:id="multidimensional-vectors_single-d-traversal"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Single Dimension Traversals</title>

  <p>It is also possible to traverse just one dimension of a multidimensional set of data. Say we just want to print out the third row of a table of data. This only requires traversing in one dimension - side to side through a single row. The list of elements we need to visit looks like:</p>

<pre>
matrix.at(2).at(0)
matrix.at(2).at(1)
matrix.at(2).at(2)
matrix.at(2).at(3)
</pre>

  <figure>
    <caption>The third row of data in a 3x4 matrix.</caption>
    <image width="45%"
           source="images/vectors-matrix3x4-lastrow.svg"/>
  </figure>

  <p>The row of everything we are trying to access is <pf>2</pf>. This means we can use a set value for the row index. Which means we do not need a loop that iterates through the various rows. Instead, we will have a single loop that traverses the columns of that row. The code looks like this:</p> 

  <listing>
  <program label="multidimensional-vectors_single-d-traversal-program-1"  highlight-lines="17, 20, 21-26" line-numbers="yes" interactive="activecode">
<xi:include href="../../programs/multidimensional-vectors/1d-traversal-1.cpp" parse="text"/>
  </program>
  </listing>
  
  <p>Note that even though we are only using a single loop to traverse one dimension, we still have to specify both a row and column to access a single <pf>int</pf> value in the table.</p>

  <insight>
    <p><pf>gridName.size()</pf> returns the number of rows when <pf>gridName</pf> is a two-dimensional vector.</p>
    <p>To get the number of columns in a particular row, use <pf>gridName.at(rowIndex).size()</pf>. If all the rows have the same number of columns, you can use <pf>gridName.at(0).size()</pf>.</p>
  </insight>
  
  <exercise label="multidimensional-vectors_single-d-traversal-ex-1">
    <statement>
      <p>This code sample is trying to print everything in column index 1 of <pf>grid</pf>:</p>
      <program>
      size_t numRows = grid.size();
      for (size_t row = 0; row &lt; numRows; ++row) {
          cout &lt;&lt; ???? &lt;&lt; endl;
      }
      </program>
      <p>What goes where the ??? are to access the current item?</p>
      <p><fillin mode="string"
                answer="grid.at(row).at(1)"/></p>
    </statement>
    <evaluation>
      <evaluate>
        <test correct="yes">
          <strcmp>grid\.at\(\s*row\s*\)\.at\(\s*1\s*\)</strcmp>
        </test>
        <test>
          <strcmp>^[^a]+$</strcmp>
          <feedback>You need to use <pf>at</pf> twice to access the element.</feedback>
        </test>
      </evaluate>
    </evaluation>
  </exercise>



</section>