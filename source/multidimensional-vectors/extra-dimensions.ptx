<section xml:id="multidimensional-vectors_extra-dimensions"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Extra Dimensions</title>

  <p>There is no reason that we have to limit ourselves to two dimensions. By nesting vectors we can create an arbitrary number of dimensions. For instance, imagine we wanted to represent ocean temperatures at various depths in different locations. We might define something like this:</p>

  <program><![CDATA[ 
  vector<vector<vector<double>>> oceanTemperatures;
  ]]>
  </program>

  <p>When representing 2 dimensions, rows and columns is a natural way to picture the data, even if what we are storing is really a list of lists.</p>

  <p>With the structure shown for <pf>oceanTemperatures</pf>, what we really have is a list, where each item is a list. And each item of those lists is another list. But we can also visualize the data as something like rows, columns, and layers.</p>

  <p>But the exact order of the dimensions is up to us. In the case of ocean temperatures, we might choose to have depth (or layer) be the first dimension. If the structure below is named <pf>oceanTemps</pf>, then <pf>oceanTemps.at(0)</pf> would refer to the top layer. <pf>oceanTemps.at(0).at(0)</pf> would refer to the uppermost latitude (row) in the top layer. And <pf>oceanTemps.at(0).at(0).at(2)</pf> would refer to the rightmost (largest latitude) location at that latitude.</p>

  <figure>
    <caption>A three dimensional arrangement where depth is the first dimension, latitude is the secondary dimension, and longitude the third.</caption>
    <image width="50%"
           source="images/vectors-extra-dimensions.svg"/>
  </figure>

  <p>Traversal of a extra-dimensional structure follows the same patterns as for simpler structures. We just need one loop per dimension. For example, if we wanted to print out the ocean temperatures, we could do something like this:</p>

  <listing xml:id="multidimensional-vectors_extra-dimensions-listing-1">
  <program label="multidimensional-vectors_extra-dimensions-program-1" interactive="activecode">
<xi:include href="../../programs/multidimensional-vectors/extra-dimensions-1.cpp" parse="text"/>
  </program>
  </listing>

  <exercise label="multidimensional-vectors_extra-dimensions-ex-1">
    <statement>
      <p>In <xref ref="multidimensional-vectors_extra-dimensions-listing-1"/>, we want to calculate an average of the temperature at each depth level. To do that, we need to declare a `total` variable to accumulate the sum of temperatures at each depth. Where should we add <pf>double total = 0;</pf>?</p>
      <program>
        <![CDATA[ 
    // Spot A
    for (size_t depth = 0; depth < depthCount; ++depth) {
        cout << "Depth " << depth << ":" << endl;
        // Spot B
        for (size_t lat = 0; lat < latitudeCount; ++lat) {
            // Spot C
            for (size_t lon = 0; lon < longitudeCount; ++lon) {
                // Spot D
                cout << oceanTemps.at(depth).at(lat).at(lon) << " ";
                total += oceanTemps.at(depth).at(lat).at(lon);
            }
            cout << endl;
            // Spot E
        }
        // Spot F
        cout << "---------------------" << endl;
    }
    // Spot G
        ]]>
      </program>

    </statement>
    <choices>
      <choice>
        <statement>
          <p>Spot A</p>
        </statement>
        <feedback>
          <p>If we declare <pf>total</pf> here, it will accumulate values from all depth levels. We want to reset it for each depth.</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>Spot B</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>Spot C</p>
        </statement>
        <feedback>
          <p>If we declare <pf>total</pf> here, it will reset for each latitude, which is not what we want.</p>
        </feedback>
      </choice>
      <choice>
        <statement>
          <p>Spot D</p>
        </statement>
        <feedback>
          <p>If we declare <pf>total</pf> here, it will reset for each longitude, which is not what we want.</p>
        </feedback>
      </choice>
      <choice>
        <statement>
          <p>Spot E</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>Spot F</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>Spot G</p>
        </statement>
      </choice>
      </choices>
      </exercise>

      
  <exercise label="multidimensional-vectors_extra-dimensions-ex-2">
    <statement>
      <p>In <xref ref="multidimensional-vectors_extra-dimensions-listing-1"/>, we want to calculate an average of the temperature at each depth level. To do that, we need to declare a `total` variable to accumulate the sum of temperatures at each depth. Then we will need to calculate the average by dividing the total by the number of temperature readings at that depth. Where should we add code to do that math and print the average for the current depth?</p>
      <program>
        <![CDATA[ 
    // Spot A
    for (size_t depth = 0; depth < depthCount; ++depth) {
        cout << "Depth " << depth << ":" << endl;
        // Spot B
        for (size_t lat = 0; lat < latitudeCount; ++lat) {
            // Spot C
            for (size_t lon = 0; lon < longitudeCount; ++lon) {
                // Spot D
                cout << oceanTemps.at(depth).at(lat).at(lon) << " ";
                total += oceanTemps.at(depth).at(lat).at(lon);
            }
            cout << endl;
            // Spot E
        }
        // Spot F
        cout << "---------------------" << endl;
    }
    // Spot G
        ]]>
      </program>

    </statement>
    <choices>
      <choice>
        <statement>
          <p>Spot A</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>Spot B</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>Spot C</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>Spot D</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>Spot E</p>
        </statement>
        <feedback>
          <p>If we calculate and print the average here, it will be done for each latitude, which is not what we want.</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>Spot F</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>Spot G</p>
        </statement>
        <feedback>
          <p>If we calculate and print the average here, it will be done once for the entire ocean.</p>
        </feedback>
      </choice>
      </choices>
    </exercise>

      
  <exercise label="multidimensional-vectors_extra-dimensions-ex-3" indentation="hide">
    <statement>
      <p>In <xref ref="multidimensional-vectors_extra-dimensions-listing-1"/>, we want to print out a single vertical column of ocean temperatures at latitude index 1, longitude index 2. Build the necessary logic.</p>
      
      <p>You will NOT use all of the blocks.</p>
    </statement>
      <blocks>
        <block>
          <cline><![CDATA[for (size_t depth = 0; depth < depthCount; ++depth) {]]></cline>
        </block>
        <block correct="no">
          <cline><![CDATA[ for (size_t lat = 0; lat < latitudeCount; ++lat) {]]></cline>
        </block>
        <block correct="no">
          <cline><![CDATA[   for (size_t lon = 0; lon < longitudeCount; ++lon) {]]></cline>
        </block>
        <block>
          <choice correct="yes">
            <cline><![CDATA[ cout << oceanTemps.at(depth).at(1).at(2) << endl;]]></cline>
          </choice>
          <choice>
            <cline><![CDATA[ cout << oceanTemps.at(depth).at(lat).at(2) << endl;]]></cline>
          </choice>
          <choice>
            <cline><![CDATA[ cout << oceanTemps.at(depth).at(lat).at(lon) << endl;]]></cline>
          </choice>
          <choice>
            <cline><![CDATA[ cout << oceanTemps.at(depth).at(1).at(lon) << endl;]]></cline>
          </choice>
        </block>
        <block>
          <cline>}</cline>
        </block>
        <block correct="no">
          <cline> }</cline>
          <cline>}</cline>
        </block>
        <block correct="no">
          <cline>  }</cline>
          <cline> }</cline>
          <cline>}</cline>
        </block>
      </blocks>
      <hint><p>How many dimensions are you traversing? That determines the number of loops you need.</p></hint>
    </exercise>


</section>