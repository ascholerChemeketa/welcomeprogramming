<section xml:id="structs_functions"
         xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Structures with Functions</title>
  <p>You can pass structures as parameters just like any built in data type. For example, <pf>printPoint</pf> below takes a point as an argument and outputs it in the standard format. If you call <pf>printPoint (blank)</pf>,
    it will output <pf>(3, 4)</pf>.</p>
  <program>void printPoint(Point p) {
  cout &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")" &lt;&lt; endl;
}</program>

  <p>That version of the function uses <term>pass by value</term> to make a copy of the point that is passed in. For a very simple struct, we may be willing to pay the price of an unneeded copy. But in general, it is better to use <term>pass by reference</term> to pass structs to avoid that work. (See <xref ref="references-exceptions_references-functions" />to review references and pass by reference.)</p>

  <p>And, if the function will not modify the struct, we should use <term>pass by const reference</term>. So we will prefer to write functions like this:</p>
  <program>void printPoint(const Point&amp; p) {
  cout &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")" &lt;&lt; endl;
}</program>
  <p>As a second example, here is a <pf>distance</pf> that takes
    two <pf>Point</pf>s as parameters:</p>

  <listing>
  <program label="structs_functions-program-1" interactive="activecode">
<xi:include href="../../programs/structs/structs_functions-1.cpp" parse="text"/>
  </program>
  </listing>

  <p>Similarly, we can return a struct from a function. To do so, we use the struct's type as the return type. Here is a function that takes a Point and returns a new Point representing its mirror image over the y-axis:</p>

  <listing>
  <program label="structs_functions-program-2" interactive="codelens">
<xi:include href="../../programs/structs/structs_functions-2.cpp" parse="text"/>
  </program>
  </listing>

  <exercise label="structs_functions-ex-1">
    <statement>
      <p>What should replace the <c>???</c> in the code below to take a coordinate as a constant reference?</p>
      <p><fillin mode="string" answer="const Coordinate&amp; p"/></p>

      <program line-numbers="yes">
        <code><![CDATA[
struct Coordinate {
  int x, y;
};

void printOppositeCoordinate(???) {
  cout << "(" << -p.y << ", " << -p.x << ")" << endl;
}

int main() {
  Coordinate coord = { 2, 7 };
  printOppositeCoordinate(coord);
}
]]></code>
      </program>
    </statement>
    <evaluation>
      <evaluate>
        <test>
          <strcmp>const\\s+Coordinate&amp;\\s+p</strcmp>
        </test>
        <test>
          <strcmp>^[^&amp;]*$</strcmp>
          <feedback>
            We want to pass by reference to avoid making a copy.
          </feedback>
        </test>
        <test>
          <strcmp>^[^p]*$</strcmp>
          <feedback>
            What is the name of the parameter that is used inside of the function?
          </feedback>
        </test>
        <test>
          <strcmp>^\\s*Coor.*</strcmp>
          <feedback>
            We want a constant reference.
          </feedback>
        </test>
      </evaluate>
    </evaluation>
  </exercise>
  <exercise label="structs_functions-ex-2"
            numbered="yes"
            adaptive="yes"
            indentation="hide">
    <statement>
      <p>Construct a function that takes in three Point structures and returns a new point where the x value is the  the average of the three points' x coordinates and the y value is the average of the three points' y coordinates. You will not need all of the blocks.</p>
    </statement>
    <blocks>
      <block name="a" depends="">
        <cline>Point average(const Point&amp; p1,</cline>
        <cline>               const Point&amp; p2,</cline>
        <cline>               const Point&amp; p3) {</cline>
      </block>
      <block name="b" depends="a">
        <cline> double avgX = (p1.x + p2.x + p3.x)/3;</cline>
      </block>
      <block name="c" depends="a">
        <choice correct="yes">
          <cline> double avgY = (p1.y + p2.y + p3.y)/3;</cline>
        </choice>
        <choice>
        <cline> double avgY = (y.p1 + y.p2 + y.p3)/3; </cline>
        </choice>
      </block>
      <block name="d" depends="b c">
        <choice correct="yes">
        <cline><![CDATA[ Point avg = {avgX, avgY};]]></cline>
        </choice>
        <choice>
        <cline><![CDATA[ Point avg = (avgX, avgY);]]></cline>
        </choice>
      </block>
      <block name="e" depends="d">
        <choice correct="yes">
        <cline><![CDATA[ return avg;]]></cline>
        </choice>
        <choice>
        <cline><![CDATA[ return Point;]]></cline>
        </choice>
      </block>
      <block name="f" depends="e">
        <cline>}</cline>
      </block>
    </blocks>
  </exercise>
</section>