<section xml:id="structs_vectors_structs"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Vectors of Structs</title>

  <introduction>
    <p>In the previous section, we saw how we can have a struct that contains a vector as one of its members. It is also possible to have a vector whose elements are structs.</p>
  </introduction>

  <subsection>
    <title>A Vector of Students</title>
    <p>Now imagine we have a large number of students and we would like to be able to write code that loops through all of the students to perform various calculations. We want to think of our data as a list of students. To accommodate this, we would want to make a vector of type <pf>Student</pf>.</p>

    <listing>
    <program>
// Make the students vector
vector&lt;Student> students;

// Add two students to the vector
Student student1 = {
  "Beth Jones",
  { 84.2, 94.3, 96.7 }
};
Student student2 = {
  "John Smith",
  { 78.2, 88.3, 92.7 }
};
students.push_back(student1);
students.push_back(student2);
    </program>
    </listing>

    <p>That code would result in memory that could be visualized as follows:</p>

    <figure align="center">
    <caption>The memory diagram for the <pf>students</pf> vector</caption>
      <image source="images/structs-vector-struct.svg"
             width="90%"
             >
        <shortdescription>A students vector with two student elements</shortdescription>
      </image>
    </figure>

    <p>That memory diagram can be helpful to figure out how we reference a particular piece of information.
      <ul>
        <li><pf>students</pf> is the top level name of the vector.</li>
        <li>The two elements of the vector are accessed using the <pf>at</pf> method. So to access the first student, we would use <pf>students.at(0)</pf>. At that point, we are naming the box that is above 0. It is the entire <pf>Student</pf> struct for Beth.</li>
        <li>To access a member of the struct, we use <pf>.fieldName</pf>. So to access the name of that student, we would use <pf>students.at(0).name</pf>.</li>
        <li>To access the exam scores of that student, we would use <pf>students.at(0).exams</pf>. That names the entire vector of scores for that student. To get a particular exam we would use <pf>.at</pf> to index into the vector. Thus <pf>students.at(0).exams.at(1)</pf> would get the second score of the first student. (94.3)</li>
      </ul></p>
  </subsection>

  <subsection>
    <title>Avoiding Copies</title>

    <p>As we work with a collection of structs, we will want to be careful to avoid making unwanted copies of structs. If we are just reading data, making copies of data will be slightly inefficient, but should be otherwise harmless. However, when we are modifying data, copies can easily introduce bugs. If we by accident make a copy of an item and change it instead of the original, our changes will not be reflected in the vector.</p>

    <p>The key to remember is that assignment into a struct variable copies. Consider this failed attempt to set the first student's first exam score to 100:</p>

    <listing>
    <program>
vector&lt;Student> students;
// assume code here adds some students to the vector
// the first student is "Beth Jones" and has exam scores of 84.2, 94.3, 96.7

// This COPIES the first student
Student s1 = students.at(0);
s1.exams.at(0) = 100.0;
    </program>
    </listing>

<p><pf>s1</pf> is a copy of the data from the vector. It is a duplicate of the <q>Beth Jones</q> Student struct:</p>

    <figure align="center">
    <caption>The memory diagram for the <pf>students</pf> vector and s1</caption>
      <image source="images/structs-vector-struct-copy.svg"
             width="90%"
             >
        <shortdescription>s1 is a copy of the first student element</shortdescription>
      </image>
    </figure>


    <p>That is great if we wanted to copy the student. But in this case, we were just trying to make it easier to refer to that student. We didn't want to write out <pf>students.at(0).exams.at(0)</pf>. <pf>s1</pf> was just supposed to be a shorter alias for <pf>students.at(0)</pf>. But because <pf>s1</pf> is a copy, we never managed to change the score of the original <q>Beth Jones</q> struct.</p>

    <p>To avoid making a copy, we can use a reference. In this situation, we do not want a copy, we just want an <term>alias</term> (temporary nickname) for the existing struct. So we should declare <pf>s1</pf> to be a reference variable and use that to refer to the student:</p>

    <listing>
    <program>
vector&lt;Student> students;
// assume code here adds some students to the vector

// Make a reference to the first student
Student&amp; s1 = students.at(0);
s1.exams.at(0) = 100.0; // This modifies the student in the vector
    </program>
    </listing>

    <figure align="center">
    <caption>The memory diagram for the <pf>students</pf> vector and s1 as a reference</caption>
      <image source="images/structs-vector-struct-ref.svg"
             width="90%"
             >
        <shortdescription>s1 is a reference to the first student element</shortdescription>
      </image>
    </figure>

    <p>Now <pf>s1.exams.at(0) = 100.0</pf> correctly changes the score in the vector.</p>

    <p>A common place to run into this issue is while trying to loop through students using a range-based for loop. Say I want to clear all of the exams for each student. So I write the code below to loop through all the students and call clear on their exams vector:</p>

  <listing>
      <caption>Failed attempt to clear all the exams for each student</caption>
  <program line-numbers="yes" highlight-lines="1">
  for (Student s : students) {
    s.exams.clear();
    // BAD: This copies the student and clears the copy's exams
  }
  </program>
  </listing>

    <p>In that attempt <pf>s</pf> is a copy of the <q>current student</q>. Changing it does not affect the original student in the vector. To avoid this, we should use a reference as the loop variable's type:</p>

    <listing>
      <caption>Correct way to clear all exams for each student</caption>
    <program line-numbers="yes" highlight-lines="1">
for (Student&amp; s : students) {
    s.exams.clear();
    // GOOD: This uses a reference to avoid copying
}
  </program>
    </listing>

    <insight>
      <p>This is an issue with range-based loops because they always use a temporary variable to store <q>the current element</q>.</p>
      <p>In a counting loop, it is more common to refer to the current element directly using its index: <pf>students.at(i)</pf>. But if you
      did want to give a temporary name to <q>the current element</q>, you would want to use a reference. Something like: <pf>Student&amp; s = students.at(i);</pf></p>
    </insight>



  </subsection>

  
  <exercise label="structs_vectors_structs-ex-1">
    <statement>
      <p>Below is a struct <pf>CarType</pf> and a code snippet that creates a vector of those called <pf>carList</pf>. What could replace the <pf>???</pf> so that the <pf>make</pf> of the third <pf>CarType</pf> in the <pf>carList</pf> is set to <pf>"Ford"</pf>?</p>
      <p><fillin mode="string" answer="carList.at(2).make"/></p>
          <program>
struct CarType {
  string make;
  vector&lt;string> models;
};
...
vector&lt;CarType> carList;
...code that adds cars to the list...
??? = "Ford";
</program>
    </statement>
    <evaluation>
      <evaluate>
        <test correct="yes">
          <strcmp>carList\.at\(\s*2\s*\)\.make</strcmp>
        </test>
        <test>
          <strcmp>.*3.*</strcmp>
          <feedback>
            Third here means the third element of the vector, not the element at index 3.
          </feedback>
        </test>
        <test>
          <strcmp>.*</strcmp>
          <feedback>
            Try again! You need to access the vector, then the right element, then the right member.
          </feedback>
        </test>
      </evaluate>
    </evaluation>
    <hint><p>Your answer should have three parts separated by dots. You will need to use <pf>at(???)</pf> as one part.</p></hint>
  </exercise>
  
  <exercise label="structs_vectors_structs-ex-2">
    <statement>
      <p>Below is a struct <pf>CarType</pf> and a code snippet that creates a vector of those called <pf>carList</pf>. What could replace the <pf>???</pf> so that the 1st model of the 3rd element of <pf>carList</pf> is set to <pf>"Escort"</pf></p>
      <p><fillin mode="string" answer="carList.at(2).models.at(0)"/></p>
          <program>
struct CarType {
  string make;
  vector&lt;string> models;
};
...
vector&lt;CarType> carList;
...code that adds cars to the list...
??? = "Escort";
</program>
    </statement>
    <evaluation>
      <evaluate>
        <test correct="yes">
          <strcmp>carList\.at\(\s*2\s*\)\.models\.at\(\s*0\s*\)</strcmp>
        </test>
        <test>
          <strcmp>.*1.*</strcmp>
          <feedback>
            First here means the element at index 0.
          </feedback>
        </test>
        <test>
          <strcmp>.*3.*</strcmp>
          <feedback>
            Third here means the element at index 2.
          </feedback>
        </test>
        <test>
          <strcmp>.*</strcmp>
          <feedback>
            Try again! You need to name the vector, then the right element, then the member that is a vector, then the right element of that member.
          </feedback>
        </test>
      </evaluate>
    </evaluation>
    <hint><p>Your answer should have four parts separated by dots. You will need to use <pf>at(???)</pf> for two of the parts.</p></hint>
    <hint><p>You need to name the list, then the item in the list, then the member that is a vector, then the item in that vector.</p></hint>
  </exercise>

  
  
  <exercise label="structs_vectors_structs-ex-3">
    <statement>
      <p>Below is a struct <pf>CarType</pf> and a code snippet that creates a vector called <pf>carList</pf>. What would you write to make a variable called <pf>temp</pf> that is a reference to the first element of the vector? Fill in the two blanks below that represent the two halves of an assignment statement. (The left should be the data type, the right the value that is assigned).</p>
      <p><fillin mode="string" answer="CarType&amp; temp"/> <pf>=</pf> <fillin mode="string" answer="carList.at(0)"/><pf>;</pf></p>
          <program>
struct CarType {
  string make;
  vector&lt;string> models;
};
...
vector&lt;CarType> carList;
...code that adds cars to the list...
...your code goes here...
</program>
    </statement>
    <evaluation>
      <evaluate>
        <test correct="yes">
          <strcmp>CarType\s*&amp;\s*temp</strcmp>
        </test>
        <test>
          <strcmp>^[^&amp;]*$</strcmp>
          <feedback>
            You need an ampersand in the type to make a reference.
          </feedback>
        </test>
        <test>
          <strcmp>.*</strcmp>
          <feedback>
            Try again! You need the base type, to make it a reference, and the name of the variable.
          </feedback>
        </test>
      </evaluate>
      <evaluate>
        <test correct="yes">
          <strcmp>carList\.at\(\s*0\s*\);?</strcmp>
        </test>
        <test>
          <strcmp>.*1.*</strcmp>
          <feedback>
            First here means index 0.
          </feedback>
        </test>
        <test>
          <strcmp>.*</strcmp>
          <feedback>
            Try again! You need to name the vector, then access the right element.
          </feedback>
        </test>
      </evaluate>
    </evaluation>
  </exercise>

</section>