<section xml:id="functions-testing_arguments"
         xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Arguments</title>


    <p>Arguments are matched in order to the parameters of a function. Given <pf>int myFunction(int x, int y)</pf>, the call <pf>myFunction(3, 6)</pf>
      is passing 3 to use for the value of <pf>x</pf> and 6 to use for <pf>y</pf>. Some programming
      languages allow you to specify what argument goes with which parameter, but C++ does not. Thus
      you need to make sure you pass parameters in the correct order. If there is a function <pf>double round(double number, int places)</pf>
      and you want to call it to round 3.14159 to 2 decimal places, you must call it with <pf>round(3.14159, 2)</pf>.
      If you write <pf>round(2, 3.14159)</pf>, you are saying <q>round 2 to 3.14159 decimal places</q>.</p>

    <p>Generally, an argument passed to a function must match the type of that parameter. If you try
      to pass a value of the wrong type, C++ will look at what is being passed to decide what to do: <ol>
        <li>If the argument can safely be converted to the parameter type, C++ will do so. For
      example, if you have a function <pf>int myFunction(double x)</pf> and you call it with <pf>myFunction(3)</pf>, C++ will convert the
      integer 3 to the double 3.0.</li>
        <li>
          <p>If the argument can be converted to the parameter type, but the conversion might lose
      information C++ will give a warning. For example, if you have a function <pf>int myFunction(int x)</pf> and you
      call it with <pf>myFunction(3.14159)</pf>, C++ will warn you that information may be lost. As always, you should
      consider warnings like this to be a giant flashing danger sign. In that function call, <pf>x</pf>
      would have the value 3 and you would lose the decimal information.</p>
          <p>If you want to lose information, do a cast to explicitly tell the compiler (and other
      programmers) that you are intentionally changing the type. Something like: <pf>myFunction( static_cast&lt;int&gt;(3.14159) )</pf></p>
        </li>
        <li>If the argument cannot be converted to the parameter type, C++ will give an error. For
      example, if you have a function <pf>int myFunction(double x)</pf> and you call it with <pf>myFunction("hello")</pf>, C++ will give an
      error because it cannot convert the string <pf>"hello"</pf> into a double.</li>
      </ol>
    </p>


    <exercise label="functions-testing_arguments-ex-3">
      <statement>
        <p>Which of the following is a legal function call of the function below? Assume you are
          calling from main, where there are local variables: <pf>double p = 3.14;</pf> and <pf>int x = 12;</pf></p>
        <program>
      double multiply(int num, double other) {
        ...
      </program>
      </statement>
      <choices randomize="yes">
        <choice>
          <statement>
            <p>
              <pf>multiply(int x, double p);</pf>
            </p>
          </statement>
          <feedback id="multiple_params_2_opt_a">
            <p>Data types are not needed when calling a function.</p>
          </feedback>
        </choice>
        <choice correct="yes">
          <statement>
            <p>
              <pf>multiply(x, p);</pf>
            </p>
          </statement>
          <feedback id="multiple_params_2_opt_b">
            <p>Correct!</p>
          </feedback>
        </choice>
        <choice>
          <statement>
            <p>
              <pf>multiply(double p, int x);</pf>
            </p>
          </statement>
          <feedback id="multiple_params_2_opt_c">
            <p>Those are in the wrong order. And, we do not specify data types when passing
              arguments.</p>
          </feedback>
        </choice>
        <choice>
          <statement>
            <p>
              <pf>multiply(p, x);</pf>
            </p>
          </statement>
          <feedback id="multiple_params_2_opt_d">
            <p>Those are in the wrong order.</p>
          </feedback>
        </choice>
      </choices>
    </exercise>

    <p>As we have seen before, when you pass a variable as an argument to a function, the function
      receives a copy of the variable. This is called <term>pass by value</term>. The function can
      change the value of the parameter, but it does not change the original variable. <idx>
        <h>pass by value</h>
      </idx>
    </p>

    <p>Consider this program displayed in Codelens. Notice that when <pf>y</pf> is passed to the
      function, it is only the value <pf>5</pf> that is passed. That value is <em>copied</em> into <pf>x</pf>.
      Anything that happens to <pf>x</pf> in the function has no impact on <pf>y</pf> in <pf>main</pf>.</p>

    <listing>
    <program label="functions-testing_arguments-program-1"
             interactive="codelens">
<xi:include href="../../programs/functions-testing/parameters-arguments-1.cpp" parse="text"/>
</program>
    </listing>

    <insight>
      <p>Pass by value means that <em>values</em> are passed to functions. In pass by value you
        never really pass a <em>variable</em> to a function.</p>
    </insight>

</section>