<section xml:id="recursive-functions_tail"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Tail Recursion</title>

  <p>A <term>tail-recursive</term> function is one where the recursive call is the last operation in the function, no work is done other than returning the answer produced by the recursion. Our <pf>countdown</pf> function was tail recursive. No work happens in it after the recursive call to <pf>countdown</pf>:<idx><h>tail recursion</h></idx></p>

  <program highlight-lines="6" line-numbers="yes">
<xi:include href="../../programs/recursive-functions/tail-1.cpp" parse="text"/>
  </program>

  <p>In our other recursive recipes, we have always done something to build on the answer produced by the recursive call. For example, our <pf>factorial</pf> function takes the answer produced by the recursive call and multiplies it by the current number:</p>

  <program highlight-lines="5-6" line-numbers="yes">
<xi:include href="../../programs/recursive-functions/tail-2.cpp" parse="text"/>
  </program>

  <p>This means those functions have not been tail recursive.</p>

  <p>Why would we care if our function is tail recursive? In a function that is not tail recursive, we have to keep track of the state of each stack frame while we wait for the recursive call to return. <pf>factorial(5)</pf> needs to store its copy of <pf>n</pf> while waiting on <pf>factorial(4)</pf>. <pf>factorial(4)</pf> needs to store its copy of <pf>n</pf> while waiting on <pf>factorial(3)</pf>. And so on. If we have a very deep recursion, we can run out of stack space and get a stack overflow error.
  </p>

  <listing>
  <program label="recursive-functions_tail-program-non-tail"
           interactive="activecode">
<xi:include href="../../programs/recursive-functions/tail-program-1.cpp" parse="text"/>
  </program>
  </listing>

  <p>In a tail recursive function, there is no need to remember anything in the current stack frame. All the work at that level is already done. So, given a tail recursive function, the compiler can <q>cheat</q> and reuse the same stack frame for each recursive call. When <pf>factorial(5)</pf> calls <pf>factorial(4)</pf> a new stack frame won't be created. Instead the data for the new call will just overwrite the current stack frame.</p>

  <note>
    <p>
      This depends on the compiler being smart enough to recognize that the function is tail recursive and optimize it. Some compilers will do this optimization, but not all. In functional programming languages like Scheme that rely heavily on recursion, the language specification often requires that tail recursion be optimized. In C++, the compiler is allowed to optimize tail recursion, but it is not required to do so.
    </p>
  </note>

  <p>But how do we make the function tail recursive? <pf>factorial(4)</pf> counts on being able to ask <pf>factorial(3)</pf> for its answer and then produces its own answer based on that. To make it tail-recursive, we need to change where the work happens. We need <pf>factorial(4)</pf> to pass all the information needed to calculate a final answer to <pf>factorial(3)</pf> and count on it to return the final answer. <pf>factorial(3)</pf> will in turn have to pass all the information needed to calculate a final answer to <pf>factorial(2)</pf>.</p>
  
  <p>As always when we want to pass more information from one recursive call to the next, that means a new parameter. We will call this parameter the <pf>accumulator</pf> as it will accumulate the <q>answer so far</q>.</p>

  <program><![CDATA[int factorial(int n, int accumulator);]]></program>

  <p>Now if we start with factorial of 4, it will call <pf>factorial(3, 4)</pf> to say <q>Hey, you need to calculate 3! and multiply that by 4.</q>. <pf>factorial(3)</pf>, will take the 4, multiply it by 3, and then call <pf>factorial(2, 12)</pf> to say <q>Hey, you need to calculate 2! and multiply that by 12.</q>. Eventually we will call <pf>factorial(0, 12)</pf> to say <q>Hey, you need to calculate 0! and multiply that by 12.</q>. Factorial of 0 is still our base case. Only now, instead of returning 1, it returns the final answer. The call sequence for an initial input of 4 looks like:</p>

  <pre>
factorial(4, 1)
factorial(3, 4)
factorial(2, 12)
factorial(1, 24)
factorial(0, 24)
  </pre>
  
  <insight><p>Tail recursion focuses on doing work on the way down the recursion stack. Non-tail recursive algorithms do work on the way back out of the recursion calls.</p></insight>

  <p>Here is an implementation of that function. Note that it does the work to calculate <pf>newAccumulator</pf> (<q>the answer so far</q>) before the recursive call and then hands that value off to the next call. The result of trying to calculate something like <pf>factorial(20000)</pf> will be incorrect as we overflow the integer being used. But there is no
  stack overflow error!</p>

  <listing>
  <program label="recursive-functions_tail-program-1" interactive="codelens" >
<xi:include href="../../programs/recursive-functions/tail-3.cpp" parse="text"/>
  </program>
  </listing>

  <exercise label="recursive-functions_tail-ex-1"
  numbered="yes"
  adaptive="yes"
  indentation="hide">

  <statement>
  <p>Construct a tail recursive version of <pf>countZeros</pf>. We will add a parameter to keep track of the current count of zeros so that all the work can be done on the way down the recursion stack.</p>
  </statement>
  <blocks>
    <block order="10">
        <choice correct="yes">
          <cline><![CDATA[int countZeros(const vector<int>& numbers,]]></cline>
          <cline><![CDATA[|              size_t curIndex = 0,]]></cline>
          <cline><![CDATA[|              int zeroCount = 0) {]]></cline>
        </choice>
        <choice>
          <cline><![CDATA[int countZeros(const vector<int>& numbers,]]></cline>
          <cline><![CDATA[|              size_t curIndex = 0,]]></cline>
          <cline><![CDATA[|              int zeroCount = 1) {]]></cline>
        </choice>
    </block>
    <block order="11">
        <choice correct="yes">
          <cline><![CDATA[    if (curIndex == numbers.size()) {]]></cline>
        </choice>
    </block>
    <block order="12">
        <choice correct="yes">
          <cline><![CDATA[        return zeroCount;]]></cline>
        </choice>
        <choice>
          <cline><![CDATA[        return 0;]]></cline>
        </choice>
    </block>
    <block order="14">
        <choice correct="yes">
          <cline><![CDATA[    } else {]]></cline>
        </choice>
        <choice>
          <cline></cline>
        </choice>
    </block>
    <block order="7">
        <choice correct="yes">
          <cline><![CDATA[        if (numbers.at(curIndex) == 0) {]]></cline>
        </choice>
    </block>
    <block order="13">
        <choice correct="yes">
          <cline><![CDATA[            zeroCount++;]]></cline>
        </choice>
        <choice>
          <cline><![CDATA[            zeroCount = 1;]]></cline>
        </choice>
    </block>
    <block order="1">
        <choice correct="yes">
          <cline><![CDATA[        } ]]></cline>
        </choice>
    </block>
    <block order="3">
        <choice correct="yes">
          <cline><![CDATA[        return countZeros(numbers,]]></cline>
          <cline><![CDATA[                          curIndex + 1,]]></cline>
          <cline><![CDATA[                          zeroCount);]]></cline>
        </choice>
        <choice>
          <cline><![CDATA[        return countZeros(numbers,]]></cline>
          <cline><![CDATA[                          curIndex + 1,]]></cline>
          <cline><![CDATA[                          zeroCount + 1);]]></cline>
        </choice>
    </block>
    <block order="8">
        <choice correct="yes">
          <cline><![CDATA[    }]]></cline>
          <cline><![CDATA[}]]></cline>
        </choice>
    </block>
  </blocks>
</exercise>

</section>