<section xml:id="recursive-functions_exercises"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Exercises</title>

  
  <exercise label="recursive-functions_exercises-ex-stars-1">
    <statement>
      <p>Write a recursive function <pf>void printPattern(string s)</pf>. It will be passed a string of stars (e.g. "****") and should print out a pattern of stars that looks like this:</p>
      <pre>
****
***
**
*
      </pre>
    </statement>
    <program interactive="activecode">
        <preamble>
<xi:include href="../../programs/recursive-functions/ex-recursion-start.cpp" parse="text"/>
        </preamble>
        <code>

void printPattern(string s) {
    //YOUR CODE HERE
}

        </code>
        <postamble visible="no"><![CDATA[
int main() {
  string start;
  cin >> start;
  printPattern(start);
}]]>
        </postamble>
        <tests>
          <iotest>
            <input>****</input>
            <output>
****
***
**
*
            </output>
          </iotest>
          <iotest>
            <input>******</input>
            <output>
******
*****
****
***
**
*
            </output>
          </iotest>
          <iotest>
            <input>*</input>
            <output>
*
            </output>
          </iotest>
        </tests>
    </program>
    <hint><p>What is the shortest pattern you need to print. That will be your base case.</p></hint>
  </exercise>

  
  <exercise label="recursive-functions_exercises-ex-stars-2">
    <statement>
      <p>Write a recursive function <pf>void printPattern(string s)</pf>. It will be passed a string of stars (e.g. "****") and should print out a pattern of stars that looks like this:</p>
      <pre>
*
**
***
****
      </pre>
    </statement>
    <program interactive="activecode">
        <preamble>
<xi:include href="../../programs/recursive-functions/ex-recursion-start.cpp" parse="text"/>
        </preamble>
        <code>

void printPattern(string s) {
    //YOUR CODE HERE
}

        </code>
        <postamble visible="no"><![CDATA[
int main() {
  string start;
  cin >> start;
  printPattern(start);
}]]>
        </postamble>
        <tests>
          <iotest>
            <input>****</input>
            <output>
*
**
***
****
            </output>
          </iotest>
          <iotest>
            <input>******</input>
            <output>
*
**
***
****
*****
******
            </output>
          </iotest>
          <iotest>
            <input>*</input>
            <output>
*
            </output>
          </iotest>
        </tests>
    </program>
    <hint><p>What is the shortest pattern you need to print. That will be your base case.</p></hint>
    <hint><p>The general case should do its work after the recursive call.</p></hint>
  </exercise>

  
  <exercise label="recursive-functions_exercises-ex-stars-3">
    <statement>
      <p>Write a recursive function <pf>void printPattern(string s)</pf>. It will be passed a string of stars (e.g. "****") and should print out a pattern of stars that looks like this:</p>
      <pre>
****
***
**
*
**
***
****
      </pre>
    </statement>
    <program interactive="activecode">
        <preamble>
<xi:include href="../../programs/recursive-functions/ex-recursion-start.cpp" parse="text"/>
        </preamble>
        <code>

void printPattern(string s) {
    //YOUR CODE HERE
}

        </code>
        <postamble visible="no"><![CDATA[
int main() {
  string start;
  cin >> start;
  printPattern(start);
}]]>
        </postamble>
        <tests>
          <iotest>
            <input>****</input>
            <output>
****
***
**
*
**
***
****
            </output>
          </iotest>
          <iotest>
            <input>******</input>
            <output>
******
*****
****
***
**
*
**
***
****
*****
******
            </output>
          </iotest>
          <iotest>
            <input>*</input>
            <output>
*
            </output>
          </iotest>
        </tests>
    </program>
    <hint><p>What is the shortest pattern you need to print. That will be your base case.</p></hint>
    <hint><p>The general case will need to do work before and after the recursive call.</p></hint>
  </exercise>


  
  <exercise label="recursive-functions_exercises-ex-1">
    <statement>
      <p>Implement the recursive function: <pf>string repeat(string s, int times)</pf></p>

      <p>The returned value should be the string <pf>s</pf> repeated <pf>times</pf> times. You don't have to worry about negative values of <pf>times</pf>. Note that the function header is there, you just need to fill in the body.</p>
    </statement>
    <program interactive="activecode">
        <preamble>
<xi:include href="../../programs/recursive-functions/ex-recursion-start.cpp" parse="text"/>
        </preamble>
        <code>

string repeat(string s, int times) {
    //YOUR CODE HERE
}
        </code>
        <tests visible="yes">
<xi:include href="../../programs/recursive-functions/ex-repeat-end.cpp" parse="text"/>
        </tests>
    </program>
    <hint><p>You do need to handle 0 repetitions. What string should that produce? That is your base case.</p></hint>
    <hint><p>Say you were told to repeat the string "hello" 5 times and knew you could ask me what the value of repeating "hello" 4 times was. How could you get your answer?</p></hint>
  </exercise>

  
<exercise label="recursive-functions_exercises-ex-3">
    <statement>
      <p>Implement a recursive function to turn an integer into a string of binary digits (1s and 0s) <pf>string makeBinary(int n)</pf></p>
      <p>Use the divide by 2 method to convert decimal to binary (you can refer to <url href="https://runestone.academy/ns/books/published/welcomecs2/data-representation_binary-conversions-multiplication-division-method.html#data-representation_decimal-to-binary-1">Welcome to CS</url> for how the algorithm works).</p>
      <p>The logic for converting 13 to binary (1101):</p>

        <tabular halign="center">
          <col width="15%"/>
          <col width="15%"/>
          <col width="15%"/>
          <col width="15%"/>
          <col width="40%"/>
          <row header="yes"
              bottom="major">
            <cell>Number</cell>
            <cell>/2 Quotient</cell>
            <cell>/2 Remainder</cell>
            <cell>Result</cell>
            <cell>Comment</cell>
          </row>
          <row>
            <cell>13</cell>
            <cell>6</cell>
            <cell>1</cell>
            <cell>"1"</cell>
            <cell><p>Add 1 to answer, continue working with 6</p></cell>
          </row>
          <row>
            <cell>6</cell>
            <cell>3</cell>
            <cell>0</cell>
            <cell>"01"</cell>
            <cell><p>Add 0 to answer, continue working with 3</p></cell>
          </row>
          <row>
            <cell>3</cell>
            <cell>1</cell>
            <cell>1</cell>
            <cell>"101"</cell>
            <cell><p>Add 1 to answer, continue working with 1</p></cell>
          </row>
          <row>
            <cell>1</cell>
            <cell>0</cell>
            <cell>1</cell>
            <cell>"1101"</cell>
            <cell><p>Add 1 to answer, continue working with 0</p></cell>
          </row>
          <row>
            <cell>0</cell>
            <cell>0</cell>
            <cell>0</cell>
            <cell>"1101"</cell>
            <cell>Once we reach 0, stop.</cell>
          </row>
        </tabular>
    </statement>
    <program interactive="activecode">
        <preamble>
<xi:include href="../../programs/recursive-functions/ex-recursion-start.cpp" parse="text"/>
        </preamble>
        <code>

string makeBinary(int n) {
    // YOUR CODE HERE
}

        </code>
        <tests visible="yes">
<xi:include href="../../programs/recursive-functions/ex-binary-end.cpp" parse="text"/>
        </tests>
    </program>
  </exercise>

  
  <exercise label="recursive-functions_exercises-ex-2">
    <statement>
      <p>Write a function <pf>double investment(double money, double interestRate, int years)</pf> that returns the final value of an amount of money invested at a given interest rate for a given number of years.</p>
      <p><pf>years</pf> will never be negative, but it may be 0.</p>
      <p>The interest rate will be given as a percentage (e.g., 5.0 for 5%). Compute simple interest for each year. E.g. Starting with 10000 and an interest rate of 5%, the interest earned for the first year will be 10000 * 0.05 = 500.</p>
    </statement>
    <program interactive="activecode">
        <preamble>
<xi:include href="../../programs/recursive-functions/ex-recursion-start.cpp" parse="text"/>
        </preamble>
        <code>

double investment(double money, double interestRate, int years) {
    //YOUR CODE HERE
}

        </code>
        <tests visible="yes">
<xi:include href="../../programs/recursive-functions/ex-invest-end.cpp" parse="text"/>
        </tests>
    </program>
    <hint><p>The smallest value you need to handle is your base case.</p></hint>
    <hint><p>Each recursive case represents one more year of your money having been invested.</p></hint>
  </exercise>

  
  <exercise label="recursive-functions_exercises-ex-2b">
    <statement>
      <p>Write a function <pf>int investmentLength(double money, double goal, double interestRate)</pf> that returns the number of years it will take to reach the given investment goal if you start with the given amount of money and invest at the specified interest rate.</p>
      <p>The interest rate will be given as a percentage (e.g., 5.0 for 5%). Compute simple interest for each year. E.g. Starting with 10000 and an interest rate of 5%, the interest earned for the first year will be 10000 * 0.05 = 500.</p>
    </statement>
    <program interactive="activecode">
        <preamble>
<xi:include href="../../programs/recursive-functions/ex-recursion-start.cpp" parse="text"/>
        </preamble>
        <code>

int investmentLength(double money, double goal, double interestRate) {
    //YOUR CODE HERE
}

        </code>
        <tests visible="yes">
<xi:include href="../../programs/recursive-functions/ex-invest-end2.cpp" parse="text"/>
        </tests>
    </program>
    <hint><p>How would you know it will take 0 years to reach the goal? That will be your base case.</p></hint>
    <hint><p>If you leave the money invested until next year, what would the new amount of money be? Would the goal or interest rate change for the recursive call?</p></hint>
    <hint><p>Each recursive case represents one more year of your money having been invested. It should return a value one larger than the result of the recursive call with updated parameters.</p></hint>
  </exercise>
  

  <exercise label="recursive-functions_exercises-ex-4">
    <statement>
      <p>Implement the function: <pf>double series(int steps)</pf></p>
      <p>This function should return the sum of the first <pf>steps</pf> number of terms from the series 1 + 1/2 + 1/4 + 1/8 + 1/16....</p>
      <p>For example:
      <ul>
        <li>series(1) would give 1</li>
        <li>series(2) would give 1.5</li>
        <li>series(3) would give 1.75</li>
        <li>series(4) would give 1.875</li>
      </ul></p>
      <p>You can add another parameter. Although you do not have to, it may make the logic easier. If you want to do so, make sure it has a default value or you have a non-recursive
        version of the function to kick start things.</p>
    </statement>
    <program interactive="activecode">
        <preamble>
<xi:include href="../../programs/recursive-functions/ex-recursion-start.cpp" parse="text"/>
        </preamble>
        <code>

double series(int steps) {
    // YOUR CODE HERE
}

        </code>
        <tests visible="yes">
<xi:include href="../../programs/recursive-functions/ex-series-end.cpp" parse="text"/>
        </tests>
    </program>
    <hint><p>Add a parameter that stores the denominator to use for the current term. 1 is the same as 1/1.</p></hint>
  </exercise>

  <exercise label="recursive-functions_exercises-ex-5">
    <statement>
      <p>Implement the function int <pf>letterCount(const string&amp; s, char a)</pf>. It should return the number of times char <pf>a</pf> appears in <pf>s</pf>.</p>
      <p>If you want to avoid making substrings of s, you can create a recursive helper that the provided <pf>letterCount</pf> calls.</p>
    </statement>
    <program interactive="activecode">
        <preamble>
<xi:include href="../../programs/recursive-functions/ex-recursion-start.cpp" parse="text"/>
        </preamble>
        <code>

int letterCount(const string&amp; s, char a) {
    // YOUR CODE HERE
}

        </code>
        <tests visible="yes">
<xi:include href="../../programs/recursive-functions/ex-letterCount-end.cpp" parse="text"/>
        </tests>
    </program>
  </exercise>

  <exercise label="recursive-functions_exercises-ex-6">
    <statement>
      <p>Write a function <pf>int numLegs(const vector&lt;char>&amp; animals, int curPosition = 0)</pf>. The vector will consist only of the chars 'c' and 'd' representing "cow" or "duck".  The function should calculate the total number of legs those animals have (assume no mutations or industrial accidents... a cow has 4 and a duck has 2).</p>
      <p>Use the changing index strategy.</p>
    </statement>
    <program interactive="activecode">
        <preamble>
<xi:include href="../../programs/recursive-functions/ex-recursion-start.cpp" parse="text"/>
        </preamble>
        <code>

int numLegs(const vector&lt;char>&amp; animals, int curPosition = 0) {
    // YOUR CODE HERE
}

        </code>
        <tests visible="yes">
<xi:include href="../../programs/recursive-functions/ex-legs-end.cpp" parse="text"/>
        </tests>
    </program>
    <hint>Your recursion should change the <pf>curPosition</pf> by 1. When <pf>curPosition</pf> is the same as the <pf>.size()</pf> of the vector, you have reached the end.</hint>
  </exercise>

  <exercise label="recursive-functions_exercises-ex-7">
    <statement>
      <p>Implement the function <pf>int getMax(const vector&lt;int>&amp;, int curIndex = 0)</pf>. It should return the largest int in the vector.</p>
    </statement>
    <program interactive="activecode">
        <preamble>
<xi:include href="../../programs/recursive-functions/ex-recursion-start.cpp" parse="text"/>
        </preamble>
        <code>

int getMax(const vector&lt;int>&amp;, int curIndex = 0) {
    // YOUR CODE HERE
}

        </code>
        <tests visible="yes">
<xi:include href="../../programs/recursive-functions/ex-getmax-end.cpp" parse="text"/>
        </tests>
    </program>
    <hint>Your base case should be when the index is at the last element (<pf>.size() - 1</pf>). If there are no other elements to worry about (because you responsible for the last one), what ever value it has must be the maximum.</hint>
  </exercise>

</section>