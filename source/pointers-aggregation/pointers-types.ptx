<section xml:id="pointers-aggregation_pointers-types"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Types of Pointers</title>

  <p> Every pointer has a type. A pointer might be a <q>pointer to an int</q> (<pf>int*</pf>), a <q>pointer
    to a double</q> (<pf>double*</pf>), or a <q>pointer to a Circle</q> (<pf>Circle*</pf>). This information is
    essential because it tells the compiler how to interpret the data that the pointer points to.
    For example, given <pf>double* p</pf>, the compiler knows that if we try to use the memory <pf>p</pf>
    points at, it only makes sense to use it as a double. </p>

  <p>This sample creates three different pointers, <pf>p</pf>, <pf>p2</pf>, and <pf>p3</pf>, each of a
    different type:</p>

  <listing>
  <program label="pointers-aggregation_pointers-types-program-1"
           interactive="activecode"
           highlight-lines="8, 14, 20"
           line-numbers="yes"
           codelens="yes">
<xi:include href="../../programs/pointers-aggregation/pointers-types-1.cpp" parse="text"/>
  </program>
  </listing>

  <p>Trying to store the wrong kind of address into a pointer is a compile time error:</p>

  <listing>
  <program label="pointers-aggregation_pointers-types-program-2"
           interactive="activecode"
           highlight-lines="8"
           line-numbers="yes"
           codelens="yes">
<xi:include href="../../programs/pointers-aggregation/pointers-types-2.cpp" parse="text"/>
  </program>
  </listing>

  <p>It is also an error to try to store a value other than a memory address into a pointer. Given <pf>int x = 10;</pf>,
    we can't ask a pointer to store <pf>x</pf> - that names the value <pf>10</pf>, not the memory
    address of x.</p>

  <listing>
  <program label="pointers-aggregation_pointers-types-program-3"
           interactive="activecode"
           highlight-lines="8"
           line-numbers="yes"
           codelens="yes">
<xi:include href="../../programs/pointers-aggregation/pointers-types-3.cpp" parse="text"/>
  </program>
  </listing>

  <note>
    <p>It is possible to declare a pointer with no specific type as a <pf>void*</pf>. However, because
      that address has no defined type, the compiler won't let us do much with that address. It does
      not know if the address points at data that should be treated as a double, an int, or a
      Circle.</p>
  </note>
  
  <note>
    <p>
      Much like references, pointers can be declared <q>const</q>. But, there is an added wrinkly: you can declare either the data it points to as <q>const</q>, meaning you can't change the data through the pointer, or the pointer itself as <q>const</q>, meaning the memory address the pointer has can't be changed. You can even declare both the pointer and the data it points at as being const. Here are some examples:
      <ul>
        <li>
          <p><pf>int* const p = &amp;x</pf> p is a constant pointer to an int, meaning the pointer itself cannot be changed to point to another int, but the int it points to (<pf>x</pf>) can be modified.</p>
        </li>
        <li>
          <p><pf>const int* p = &amp;x</pf> p is a pointer to a constant int, meaning the int it points to cannot be modified through the pointer, but the pointer itself can be changed to point to another int.</p>
        </li>
        <li>
          <p><pf>const int* const p = &amp;x</pf> p is a constant pointer to a constant int, meaning neither the pointer nor the int it points to can be modified.</p>
        </li>
      </ul>
      Remember that it helps to read these declarations from right to left to understand what is constant.
    </p>

    <p>
      We will not be making use of const pointers in this book.
    </p>
  </note>

  <exercise label="pointers-aggregation_pointers-types-ex-1">
    <statement>
      <p>Which statements below are correct?</p>
    </statement>
    <choices randomize="yes">
      <choice>
        <statement>
          <p>Any pointer variable can be assigned any variable's address.</p>
        </statement>
        <feedback>
          <p>Pointers can only be assigned the address of variables of the matching type.</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>All pointers store memory addresses.</p>
        </statement>
        <feedback>
          <p>All pointers just store memory addresses.</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>The compiler uses a pointer's type to determine what can be done with what it points
            at.</p>
        </statement>
        <feedback>
          <p>That is why pointers have types.</p>
        </feedback>
      </choice>
      <choice>
        <statement>
          <p>You can assign an <pf>int</pf> value like 42 to a <pf>int*</pf>.</p>
        </statement>
        <feedback>
          <p>Pointers can only be assigned memory addresses, not the values of the type they are
            supposed to point at.</p>
        </feedback>
      </choice>
    </choices>
  </exercise>

</section>