<section xml:id="loops_sentinel-loops"
         xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Sentinel Loops</title>

  <p>A second common pattern for designing a loop (after the counting loop) is the <term>sentinel loop</term>. It is used when we don't know how many times we will need to repeat a task, but we do know when to stop. In this strategy, the loop continues until a special value is encountered, called the <term>sentinel</term>. (A <em>sentinel</em> is someone who stands guard.)
  <idx><h>sentinel loop</h></idx>
  <idx><h>loop</h><h>sentinel</h></idx>
  </p>

  <p>Here is a program that keeps reading in numbers until it encounters 0. The program does not know, or care, how many numbers it is going to get. So it isn't really <q>counting</q>, it is just continuing until it hits the sentinel value 0.</p>

  <listing>
  <program label="loops_sentinel-loops-program-1" interactive="activecode">
<code>
<xi:include href="../../programs/loops/sentinel-loops-1.cpp" parse="text"/>
</code>
<stdin>5 10 15 4 0</stdin>
</program>
  </listing>

  <p>Notice that the loop variable update - where we read in the next value for <pf>number</pf> - separates the body of the loop into two parts. The part above the update where we are using the current value of the variable, and the part after where we are using the <q>next</q> value.</p>

  <p>Sometimes, the sentinel is a <pf>bool</pf> value or function call that returns a <pf>bool</pf> as the sentinel. Loops like this are very common:</p>

  <program>
while ( !atEndOfFile() ) {
  // read a line and process it
}
  </program>

  <p>Here, the <pf>atEndOfFile</pf> function returns <pf>true</pf> or <pf>false</pf> and is serving as our sentinel.  As long as there are more lines, <pf>atEndOfFile()</pf> will be <pf>false</pf>. That means <pf>!atEndOfFile()</pf> will be <pf>true</pf> and the loop executes again.</p>

  <p>It is important to make sure that the loop eventually reaches the sentinel condition to avoid infinite loops. If our loop control variable might skip past the sentinel value, the loop may never terminate. The program below has this kind of bug. It keep multiplying the loop control variable by 2 and tries to stop when we reach 1000.</p>

  <listing>
  <program label="loops_sentinel-loops-program-2" interactive="activecode">
<code>
<xi:include href="../../programs/loops/sentinel-loops-2.cpp" parse="text"/>
</code>
</program>
  </listing>

  <p>If you run the program, it will enter an infinite loop because the value of <pf>number</pf> will never be exactly 1000. It will go from 512 to 1024 without ever equaling 1000. To fix this, we would need to rewrite the condition as something like <pf>number &lt; 1000</pf>. That way, reaching 1000 will stop the loop, even if we blow right past the sentinel value.</p>


  <exercise label="loops_sentinel-loops-ex-1"
            numbered="yes"
            adaptive="yes"
            indentation="hide">
    <statement>
      <p>Help Goku reach power levels of over 9000! Write the function powerUp which takes
        powerLevel as a parameter. powerUp checks to see if powerLevel is over 9000. If it isn't, it
        repeatedly prints <q>More power!</q> and increments powerLevel by 1000 until powerLevel is
        over 9000. Then powerUp prints <q>It's over 9000!</q>. Put the necessary blocks in the
        correct order.</p>
    </statement>
    <blocks>
      <block>
        <choice correct="yes">
          <cline>void powerUp(int powerLevel) {</cline>
        </choice>
        <choice>
          <cline>void powerUp() {                         </cline>
        </choice>
      </block>
      <block correct="no">
        <cline>   int n = 0;  </cline>
      </block>
      <block>
        <choice correct="yes">
          <cline><![CDATA[   while (powerLevel < 9000) {]]></cline>
        </choice>
        <choice>
          <cline>   while (powerLevel &gt; 9000) {  </cline>
        </choice>
      </block>
      <block>
        <cline><![CDATA[      cout << "More power!" << endl;]]></cline>
      </block>
      <block>
        <choice correct="yes">
          <cline>      powerLevel = powerLevel + 1000;</cline>
        </choice>
        <choice>
          <cline>      powerLevel++;  </cline>
        </choice>
      </block>
      <block correct="no">
        <cline>      n++;  </cline>
      </block>
      <block>
        <cline>   }</cline>
      </block>
      <block correct="no">
        <cline><![CDATA[   if (powerLevel < 9000) {  ]]></cline>
      </block>
      <block>
        <cline><![CDATA[   cout << "It's over 9000!" << endl;]]></cline>
        <cline>}</cline>
      </block>
    </blocks>
  </exercise>

</section>