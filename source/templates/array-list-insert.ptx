<section xml:id="templates-array-list_array-list-insert"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Insert End</title>

  <p>We will always keep the values in our ArrayList packed together at the start of the array. That
    means if we have 10, 20, 30 in an ArrayList with <pf>m_capacity</pf> of 5, the contents of the array will
    always look like <pf>[10, 20, 30, ???, ???]</pf>. We will never skip a space in the array by storing the items like <pf>[10, ???, 20, 30, ???]</pf>
    .</p>

  <p>Keeping the data compacted like this serves two important roles: <ul>
      <li>It makes it easy to locate elements in the ArrayList. When we want to access the element
    at index 2 of the ArrayList (the third item), we can just look at <pf>m_arr[2]</pf>. If we allowed a gap
    in the array, we would not know that the element at index 2 is actually the third item.</li>
      <li>It makes it easy to find the next available location in the array. When <pf>m_size</pf> is 3,
    that means we have items at indexes 0-2 (size - 1). The next available index would be 3.</li>
    </ul>
  </p>

  <insight>
    <p><pf>m_size</pf> is always the first location that is NOT currently in use. <pf>m_size - 1</pf> is the index
      of the last element.</p>
  </insight>

  <p>Given this design, we generally will insert items at the end of the ArrayList (similar to how
    in a vector we generally use <pf>push_back()</pf> to add items). A basic version of it might look like:</p>

  <program><![CDATA[
template<typename T>
void ArrayList<T>::insertEnd(const T& newItem) {
    m_arr[m_size] = newItem;  // place the new item in first unused location
    m_size++;                 // increase size to reflect new item
}
]]></program>

  <p>Given memory that looks like:</p>

  <figure>
    <caption><pf>intList</pf> currently has an logical size of 3.</caption>
    <image source="images/array-list-basic.svg">
      <shortdescription>The intList variable contains an m_size of 3 and m_capacity of 5. It also
        has a pointer to an array named m_arr. That array contains [10, 20, 30, ???, ???]</shortdescription>
    </image>
  </figure>

  <p>Let us imagine what would happen if <pf>insertEnd(40)</pf> was called on it. First, <pf>insertEnd</pf> would copy the
    new item into the location indicated by <pf>m_size</pf> (3). Then it will increase <pf>m_size</pf> to 4,
    telling us that elements 0-3 of the array are now valid indexes in the ArrayList.</p>

  <figure>
    <caption><pf>intList</pf> after inserting 40.</caption>
    <image source="images/array-list-insertEnd.svg">
      <shortdescription>The intList variable contains an m_size of 4 and m_capacity of 5. It also
        has a pointer to an array named m_arr. That array contains [10, 20, 30, 40, ???]</shortdescription>
    </image>
  </figure>


  <exercise label="templates-array-list_array-list-insert-ex-1">
    <statement>
      <p>Which statements are true about how we store data in an ArrayList?</p>
    </statement>
    <choices randomize="yes">
      <choice correct="yes">
        <statement>
          <p>The data is stored contiguously (without gaps) in the array.</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>The data starts at index 0.</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>The next available index is always at m_capacity - 1.</p>
        </statement>
      </choice>
    </choices>
  </exercise>

</section>