<section xml:id="templates-array-list_array-list-access-remove"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Access and Removal</title>

  <p>Accessing an item to either get the existing value or set a new one is straightforward. We
    simply perform the desired operation on the corresponding index in the array.</p>

  <program><![CDATA[
template<typename T>
T ArrayList<T>::get(int location) const {
    return m_arr[location];
}

template<typename T>
void ArrayList<T>::set(int location, const T& newValue) {
    m_arr[location] = newValue;
}
]]></program>

  <p>We likely want to sanity check the location to make sure it is valid before accessing the
    array. To do so, we can add something like this to the start of each of those functions:</p>

  <program><![CDATA[
    if (location < 0 || location >= m_size) {
        throw std::out_of_range("Index out of range");
    }
    ]]></program>

  <p>That way asking for the item at location -1 or 4 in a four item ArrayList (where only 0-3 are
    valid indexes) will throw an exception instead of accessing invalid memory.</p>

  <note>
    <p>Again, we are intentionally building a simplified version of <pf>std::vector</pf>. Although our
      ArrayList is conceptually the same as a vector, it doesn't provide exactly the same
      functionality. <pf>std::vector</pf> uses more complex code to handle element access.</p>
    <p><pf>std::vector</pf> does not have separate <pf>set</pf> and <pf>get</pf> functions. Instead, it provides an <pf>T&amp; ArrayList&lt;T>::at(int location)</pf>
      function. Because this function returns a reference, it allow consumers to write <pf>myList.at(2) = 100;</pf>.
      But it also provides a <pf>const</pf> version of exactly the same function: <pf>const T&amp; ArrayList&lt;T>::at(int location) const</pf>. The <pf>const</pf>
      version does not allow for assigning a new value, but can be used in contexts where we have
      said the vector itself is const.</p>
    <p>It also provides an overridden <pf>operator[]</pf> that does the same thing as <pf>.at()</pf> but skips the <pf>out_of_range</pf>
      check and just assume that the index is valid. </p>
  </note>


  <p>Removing an item from the end of the ArrayList is also straightforward. We simply decrease <pf>m_size</pf>
    by 1. Doing so excludes the old last item from the range of valid indexes. The value will still
    be in the array, but we no longer consider it part of the ArrayList!</p>

  <program><![CDATA[
template<typename T>
void ArrayList<T>::removeEnd() {
    m_size--;
}
    ]]></program>

  <p>For example, if we call <pf>intList.removeEnd()</pf> after inserting 40, the ArrayList would look then look like:</p>

  <figure>
    <caption><pf>intList</pf> after removing the last item. The values that are not considered part of the
      ArrayList (40 and ???) are shown in gray.</caption>
    <image source="images/array-list-remove.svg">
      <shortdescription>The intList variable contains an m_size of 3 and m_capacity of 5. It also
        has a pointer to an array named m_arr. That array contains [10, 20, 30, 40, ???]. The 40 is
        not considered part of the ArrayList anymore.</shortdescription>
    </image>
  </figure>

  <p>Again, we might want to add some sanity checking. If there is nothing in the ArrayList and <pf>removeEnd()</pf>
    is called, we should make sure not to set <pf>m_size</pf> to a negative value. We could either choose
    to throw an exception or simply do nothing in that case. (The final version of our code will
    throw an exception. See <xref ref="templates-array-list_array-list-final-listing"/>.)</p>

  <exercise label="templates-array-list_array-list-access-remove-ex-1">
    <statement>
      <p>What logic makes sense for removing all the elements in the ArrayList?</p>
    </statement>
    <choices randomize="yes">
      <choice correct="yes">
        <statement><p>Set the <pf>m_size</pf> to 0.</p></statement>
      </choice>
      <choice>
        <statement><p>Set the <pf>m_capacity</pf> to 0.</p></statement>
        <feedback>
          <p>Capacity is the size of the array. We do not want to change it as it needs to remain consistent with the allocated memory.</p>
        </feedback>
      </choice>
      <choice>
        <statement><p>Delete the array and allocate a new one.</p></statement>
        <feedback>
          <p>If we do not change the <pf>m_size</pf>, we would still think we had items in the ArrayList.</p>
        </feedback>
      </choice>
      <choice>
        <statement><p>Loop through the array and set each element to a default value. Then set the <pf>m_size</pf> to 0.</p></statement>
        <feedback>
          <p>We could do that, but there is no point in resetting elements. We can just "forget" them by setting <pf>m_size</pf> to 0.</p>
        </feedback>
      </choice>
      <choice>
        <statement><p>Loop through the array and set each element to a default value. Then set the <pf>m_capacity</pf> to 0.</p></statement>
        <feedback>
          <p>We should not change the capacity unless we are making a new array.</p>
        </feedback>
      </choice>
    </choices>
  </exercise>

</section>