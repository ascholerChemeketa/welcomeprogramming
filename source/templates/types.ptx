<section xml:id="templates-array-list_types"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Templated Data Types</title>

  <p>In addition to writing templated functions, we can also write templated data types<mdash/>structs
    or objects whose members can be of any type. For example, we might want to be able to group two
    pieces of data into a <q>pair</q>. Rather than write a struct <pf>IntPair</pf> that only works with
    integers, or a <pf>DoublePair</pf> that only works with doubles, we can write a templated struct:</p>

  <listing>
    <program>
<xi:include href="../../programs/templates-array-list/types-pair.cpp" parse="text"/>
</program>
  </listing>

  <p>This definition says that a <pf>Pair&lt;T></pf> has two member variables of type <pf>T</pf>. To use this
    templated data type, we generally must specify the type when declaring a variable of that type. <pf>Pair&lt;int></pf>
    for a pair of ints, <pf>Pair&lt;double></pf> for a pair of doubles, and so on. (The compiler may be able to
    guess the type in some cases, meaning that in those cases we could just write <pf>Pair</pf>, but it
    is best to always be explicit.)</p>

  <p>The program below demonstrates using our <pf>Pair</pf> struct with different types:</p>

  <listing>
    <program label="templates-array-list_types-1"
             interactive="activecode"
             highlight-lines="12,17">
<xi:include href="../../programs/templates-array-list/types-pair-sample.cpp" parse="text"/>
</program>
  </listing>

  <p>Of course, any function that was going to work on <pf>Pair</pf>s would need to be templated as well
    so that it can handle any type of <pf>Pair</pf>. For example, a function to compare two <pf>Pair</pf>s
    might look like:</p>

  <listing>
    <program>
<xi:include href="../../programs/templates-array-list/types-pair-function.cpp" parse="text"/>
</program>
  </listing>

  <exercise label="templates-array-list_types-exercises-1"
           numbered="yes"
           indentation="hide">

    <statement>
      <p>Define a templated struct <pf>LabeledValue</pf> that holds a <pf>value</pf> of type <pf>T</pf> and a <pf>label</pf> of type <pf>string</pf> (in that order).</p>
    </statement>
    <blocks>
      <block><cline><![CDATA[template <typename T>]]></cline></block>
      <block>
        <choice correct="yes"><cline><![CDATA[struct LabeledValue {]]></cline></choice>
        <choice><cline><![CDATA[struct<T> LabeledValue {]]></cline></choice>
        </block>
      <block>
        <cline><![CDATA[    T value;]]></cline>
      </block>
      <block>
        <cline><![CDATA[    string label;]]></cline>
      </block>
      <block><cline><![CDATA[};]]></cline></block>
      </blocks>
  </exercise>

  <exercise>
    <statement>
      <p>Declare a variable named <pf>item</pf> that is a <pf>LabeledValue</pf> of type <pf>double</pf>.</p>
      <p>
        <fillin mode="string" width="30"
                answer="LabeledValue&lt;double> item;"/>
      </p>
    </statement>
    <evaluation>
      <evaluate>
        <test>
          <strcmp>LabeledValue\\s*&lt;\\s*double\\s*>\\s*item\\s*;?</strcmp>
        </test>

        <test>
          <strcmp>^[^&lt;]*$</strcmp>
          <feedback>You need the angle brackets</feedback>
        </test>
        <test>
          <strcmp>.*T.*</strcmp>
          <feedback>There should not be a <pf>T</pf></feedback>
        </test>
      </evaluate>
    </evaluation>
  </exercise>

</section>