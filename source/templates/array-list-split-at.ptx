<section xml:id="templates-array-list_array-list-split-at"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Split At</title>

  <p>
    One of the advantages of having built a data structure is that we can add exactly whatever features
    are important to us. One operation we might want to support is splitting an ArrayList into two separate ArrayLists. For example, if we have an ArrayList that contains <pf>{10, 20, 30, 40, 50}</pf> and we want to split it at index 2, we would end up with two ArrayLists: one containing <pf>{10, 20}</pf> and the other containing <pf>{30, 40, 50}</pf>.
  </p>

  <p>
    Let's start by designing the interface for this function. We will call it <pf>splitAt</pf> and will plan on it taking an index as a parameter. The original ArrayList we call it on will be modified to only contain the items up to that point. To store the items after the split point, we will return a new ArrayList that contains those items. So the function signature might look like this:
  </p>

  <program>
    <![CDATA[
ArrayList<T> ArrayList<T>::splitAt(int index);
    ]]>
  </program>

  <p>
    To implement this function, we can either focus on using existing functions or construct logic from scratch.
    Using existing functions is often easier and less error prone. However, their abstraction have the potential for hiding possible inefficiencies. So if we use existing functions, we need to be careful to choose ones that don't do unnecessary work.
  </p>

  <p>
    To make sure we understand what work really is required, let's start with a fresh implementation that doesn't use any existing functions. Once we have that designed, we can decide if existing functions can simplify the implementation without adding too much overhead.
  </p>

  <p>
    Thinking about what the state of memory should look like before and after a call to split can help us decide what work to do. Imagine we have an ArrayList that contains <pf>{10, 20, 30, 40, 50}</pf> and we call <pf>splitAt(2)</pf> on it. Memory might look like the left hand at the start of the call and the right hand at the end of the call (Click to enlarge):
  </p>

  <sidebyside widths="45% 45%">
  <figure>
    <caption>Memory at the start of <pf>splitAt(2)</pf>.</caption>
    <image source="images/array-list-split-at-1.svg">
      <shortdescription><p>"this" object has a m_size of 5, m_capacity of 6, and a pointer to an array named m_arr. That array contains [10, 20, 30, 40, 50, ???]</p></shortdescription>
    </image>
  </figure>
  
  <figure>
    <caption>Memory at the end of <pf>splitAt(2)</pf>. Changes are in blue.</caption>
    <image source="images/array-list-split-at-2.svg">
      <shortdescription><p>"this" object has a m_size of 2, m_capacity of 6, and a pointer to an array named m_arr. That array contains [10, 20, ???, ???, ???, ???]</p>
        <p>"rear" object has a m_size of 3, m_capacity of 3, and a pointer to an array named m_arr. That array contains [30, 40, 50, ???, ???, ???]</p>
      </shortdescription>
    </image>
  </figure>
  </sidebyside>

  <p>
    There is no need to change the actual array that <pf>this</pf> is pointing to. Nor do we need to actually delete anything. We can just change the logical size of <pf>this</pf> to reflect that it now only contains the first two items. The new ArrayList we will call <pf>rear</pf>. It needs to have storage space for the number of items being split off (size - index) in a new array. It might be OK to have more space, but certainly not less. And we will need to copy the items being split off into that new array.
  </p>

  <p>
    To make the new ArrayList for the rear half, we can call the default constructor. But it might not allocate enough space for the items we need to store. So we will need to check if the default capacity is sufficient and if not, we will allocate a new array with enough capacity. Let's focus on setting up the new ArrayList first and then we can worry about copying items into it.
  </p>

  <aside>
    <p>At this point, it might be smart to create a constructor that takes a capacity parameter so we can create an ArrayList with a specific capacity right from the start. Or a <pf>resize(size)</pf> function that grows to a specified size.</p>
    <p>But we'll continue on without those.</p>
  </aside>

  <listing>
    <program line-numbers="yes">
    <![CDATA[
template<typename T>
ArrayList<T> ArrayList<T>::splitAt(int index) {
    ArrayList<T> rear;
    int numItemsToSplit = m_size - index;
    if (rear.m_capacity < numItemsToSplit) {
        delete[] rear.m_arr; // free the default array
        // change capacity and allocate new array
        rear.m_capacity = numItemsToSplit;
        rear.m_arr = new T[numItemsToSplit]; 
    }

    // copy items from index to the end into rear's array

    // "remove" them from the original ArrayList
    m_size = index;

    return rear;
}
]]></program>
  </listing>

  <p>Lines 5-10 handle checking to see if the newly created <pf>rear</pf> has enough capacity and if not, allocates a new array with sufficient capacity. 
    Line 15 handles <q>removing</q> the items from the original ArrayList by changing the logical size of <pf>this</pf>.
  </p>

  <p>
    In between, we just need to copy items over. We have already calculated how many items we need to copy in the <pf>numItemsToSplit</pf> variable. We can use that to loop through the items being split off and copy them into the new array. The items will go into index 0 through <pf>numItemsToSplit - 1</pf> of the new array. In the original array, the items we want to copy start at index <pf>index</pf>. So we need to offset the loop counter by <pf>index</pf> to get the correct item from the original array.
  </p>

  
  <listing>
    <program line-numbers="yes">
    <![CDATA[
template<typename T>
ArrayList<T> ArrayList<T>::splitAt(int index) {
   ... same as before  ...

    // copy items from index to the end into rear's array
    for (int i = 0; i < numItemsToSplit; ++i) {
        int oldArrayIndex = index + i;
        rear.m_arr[i] = m_arr[oldArrayIndex];
    }

    ... same as before ...
}
]]></program>
  </listing>

  <p>
     That implementation does all the required work. The only obvious <q>extra</q> work is possibly having to allocate a new array if the default constructor didn't allocate enough space. But, unless we go implement a constructor with a size parameter, we will need to do that work in this function.
  </p>

  <p>
    Aside from implementing new functions, can we use any existing functions to simplify this implementation? Maybe we could use <pf>removeAt</pf> and <pf>insertAt</pf> to move items. Doing that could look as simple as:
  </p>

  <listing>
    <program line-numbers="yes">
    <![CDATA[
template<typename T>
ArrayList<T> ArrayList<T>::splitAt(int index) {
    ArrayList<T> rear;
    int numItemsToSplit = m_size - index;
    for(int i = 0; i < numItemsToSplit; ++i) {
        int value = m_arr[index]; // get the value at the split point
        rear.insertEnd(value);
        removeAt(index); // remove the item at the split point from "this"
    }
    return rear;
}
]]></program>
  </listing>

  <p>
     This is certainly simpler to read. And it also is doing less new work, which means fewer opportunities for new bugs. We don't even have to worry about the capacity as the <pf>insertEnd</pf> function will take care of growing if we need to!
  </p>

  <p>
     However, it is doing a lot of extra work. It keeps removing the item at the split point, which means that every time we remove an item, all the items after it have to shift down. Given our example list of <pf>{10, 20, 30, 40, 50}</pf>, the first time we remove at index 2, we take the have to shift 40 and 50 down so that <pf>{10, 20, 40, 50}</pf> are compact in memory. The second time we remove at index 2, we have to shift 50 down.
     It would be even worse if we were splitting an ArrayList with 1,000 items at index 2 (997 items would need to shift, then 996, then 995, etc...)</p>

    <p>It seems like we are doing a lot of extra work shifting items around that we don't need to do if we just copy the items directly into the new array. (We will develop a language to quantify this extra work in <xref ref="big-o"/>.)
    So, let's avoid using <pf>removeAt</pf>. We can just not remove during the loop and go back to changing the logical size after the loop is complete.</p>

    <p><pf>insertEnd</pf> is not as problematic. Because it always adds to the end of the ArrayList, we don't have to do any shifting of existing items. Yes, it might need to grow a few times, but unless we build a way to create the new ArrayList with the correct capacity from the start, we will need to do that work somewhere.
    </p>

  <listing>
    <program line-numbers="yes">
    <![CDATA[
template<typename T>
ArrayList<T> ArrayList<T>::splitAt(int index) {
    ArrayList<T> rear;
    int numItemsToSplit = m_size - index;
    for(int i = 0; i < numItemsToSplit; ++i) {
        int oldArrayIndex = index + i;
        int value = this->m_arr[oldArrayIndex];
        rear.insertEnd(value);
    }
    m_size = index; // "remove" the items from the original ArrayList
    return rear;
}
]]></program>
  </listing>

    <insight>
      <p>Great code is both efficient and easy to understand. But sometimes those two goals are at odds with each other. In that case, you have to strike a balance or decide which goal is more important for a given situation.</p>
    </insight>

  
  <exercise label="templates-array-list_array-list-split-at-ex-1"
            adaptive="yes"
            indentation="hide">
    <statement>
      <p>Design the code for a <pf>ArrayList&lt;T> removeSlice(int index, int length)</pf> function for ArrayList. (<pf>ArrayList&lt;T></pf> is abbreviated as <pf>AL&lt;T></pf> in the code.)</p>

      <p>It should remove a contiguous slice of items from the ArrayList starting at <pf>index</pf>. For example, if we have an ArrayList that contains <pf>{10, 20, 30, 40, 50, 60}</pf> and we call <pf>removeSlice(1, 3)</pf>, we would remove and return a new list with <pf>{20, 30, 40}</pf>, leaving behind <pf>{10, 50, 60}</pf>.</p>

      <p>We will build it without using <pf>removeAt</pf> by first copying items to the slicedItems array, and then moving each item after the slice down to fill the gap.</p>
    </statement>
    <blocks>
      <block order="5" name="a" depends="">
          <cline><![CDATA[template<typename T>]]></cline>
      </block>
      <block order="3" name="b" depends="a">
          <cline><![CDATA[AL<T> AL<T>::removeSlice(int index, int length) {]]></cline>
      </block>
      <block order="2" name="c" depends="b">
          <cline><![CDATA[  AL<T> slicedItems;]]></cline>
      </block>
      <block order="8" name="d" depends="b">
          <cline><![CDATA[  int endOfSliceIndex = index + length - 1;]]></cline>
      </block>
      <block order="4" name="e" depends="b,d">
          <cline><![CDATA[  for (int i = index; i <= endOfSliceIndex; ++i) {]]></cline>
      </block>
      <block order="11" name="f" depends="e">
          <cline><![CDATA[      slicedItems.insertEnd(m_arr[i]);]]></cline>
          <cline><![CDATA[  }]]></cline>
      </block>
      <block order="9" name="h" depends="f">
          <cline><![CDATA[  for (int i = endOfSliceIndex + 1; i < m_size; ++i) {]]></cline>
      </block>
      <block order="1" name="i" depends="h">
          <cline><![CDATA[      m_arr[i - length] = m_arr[i];]]></cline>
          <cline><![CDATA[  } ]]></cline>
      </block>
      <block order="13" name="k" depends="i">
          <cline><![CDATA[  m_size -= length;]]></cline>
      </block>
      <block order="6" name="l" depends="">
          <cline><![CDATA[  return slicedItems;]]></cline>
      </block>
      <block order="12" name="m" depends="">
          <cline><![CDATA[} // end of function]]></cline>
      </block>
    </blocks>
  </exercise>

</section>