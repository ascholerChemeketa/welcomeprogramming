<section xml:id="search-sort_quick-sort"
         xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Quick Sort</title>

  <p>With our partition algorithm in place, we can now implement <idx>quick sort</idx>. Here is the pseudocode:</p>

  <pre>
    QuickSort(list, start, end):
      if start >= end:
        return list  // size 0/1 already sorted
      else:
        pivotLocation = Partition(list)
        QuickSort(0 to pivotLocation - 1)  // Sort the first half
        QuickSort(pivotLocation to end)    // Sort the second half
  </pre>


  <p>Implemented in C++ for a vector, it looks like this:</p>
  

  <listing>
    <program label="search-sort_quick-sort"
             interactive="activecode"
             line-numbers="yes"
             highlight-lines="14-32"
             add-files="search-sort_vector-helpers-h">
    <code>
<xi:include href="../../programs/search-sort/quick-sort.cpp" parse="text"/>
    </code>
  </program>
  </listing>


  <p>Again we use a wrapper function <pf>quickSort(vector&lt;T>&amp; vec)</pf> to start the recursive quick sort function. It means that main does not have to provide the start and end indices.</p>

  <p>
    Try running this interactive to see how the process plays out. As you do so, pay attention to when elements turn white. Those elements are in their final sorted position.
    Each partition step places one element (the pivot) into its final sorted position. Quick sort then recursively sorts the left and right partitions around that pivot.
  </p>

  <activity xml:id="search-sort_quick-sort-activity">
    <title>QuickSort</title>

    <interactive width="150%"
                 aspect="6:3.2"
                 iframe="interactives/quick-sort/index.html"
                 label="search-sort_quick-sort-interactive">
      <instructions>
        <p>Click "Step" to advance once step or "Play" to run continuously.</p>
        <p>At the top, you can see a description of the current step. On the right, you can see the current call stack.</p>
      </instructions>
    </interactive>
  </activity>

  <p>This process is not <term>stable</term>. Say you had the partition:</p>
  
  <pre>5 1(A) 1(B) 10 15</pre>

  <p>The first swap would produce:</p>
  
  <pre>5 15 1(B) 10 1(A)</pre>

  <p>This reverses the order of the two 1s. Recall that any time elements are swapping across large distance without consideration for other <q>equal</q> elements, an algorithm is going to almost certainly be unstable. This is the case for quick sort.</p>

  <exercise label="search-sort_quick-sort-ex-1">
    <statement>
      <p>Which statements are true about quick sort?</p>
    </statement>
    <choices>
      <choice correct="yes">
        <statement><p>Quick sort is a divide-and-conquer algorithm.</p></statement>
      </choice>
      <choice correct="yes">
        <statement><p>Quick sort uses a partitioning step to divide the list into two parts.</p></statement>
      </choice>
      <choice>
        <statement><p>Quick sort always partitions the list into two equal sized parts.</p></statement>
      </choice>
      <choice correct="yes">
        <statement><p>Quick sort recursively sorts the left and right partitions around the pivot.</p></statement>
      </choice>
      <choice>
        <statement><p>Quick sort is stable.</p></statement>
      </choice>
    </choices>
  </exercise>

</section>