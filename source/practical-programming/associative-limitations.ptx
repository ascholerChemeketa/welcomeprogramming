<section xml:id="practical-programming_associative-limitations"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Traversing Containers</title>

  <p>A <pf>list</pf> allows for things that
    would be much more difficult or inefficient with a vector. However, they do have their own
    limitations. One key limitation is that none of these containers allow you to access elements directly by
    their position (index) in the collection. Given a <pf>std::list</pf> it is an error to say something like <pf>myList.at(3)</pf>
    to try to get the 4th element.</p>

  <note>
    <p>Accessing elements by position like this is is often referred to as <term>random access</term>.
      It is not that we are accessing a random element, but rather that we can directly access any <q>
      random</q>element we want by its position. <idx>random access</idx></p>
  </note>

  <p>Because lists do not support access by index, we can't write a counting loop
    that goes from 0 to size()-1 and accesses each element using <pf>.at(i)</pf>. Instead, we have to use an
    iterator to walk through all the elements in the container. (Or use a range based loop, which
    behind the scenes uses iterators.)</p>

  <p>When we introduced iterators in <xref ref="vectors_insertion-removal"/>, we described them as a
    way to specify the location of an element in a vector. In a vector, an iterator feels a little
    redundant because we can also specify locations using indices. But in containers like lists,
    iterators are essential because we can not say <q>the thing at index 3</q>. </p>

  <p>Think of an iterator as a <q>smart pointer</q> to an element in a collection. It can be used to
    access the element it points to. Depending on the type of collection, the iterator may also be
    able to move to the next or previous element in the collection, and/or jump to a particular
    element. </p>

  <p>In a vector, we could get an iterator to the start of the vector using <pf>
    .begin()</pf> and an
    iterator to one past the end using <pf>.end()</pf>. We could then modify that iterator using
    expressions like <pf>myVec.begin() + 2</pf> to get an iterator that points to the third element of the vector. </p>


    <figure>
      <caption>Vector iterators can jump to any position in the vector.
      </caption>
      <image source="images/vectors-iterators.svg" width="40%">
        <shortdescription>A vector with various iterators shown.</shortdescription>
      </image>
    </figure>


  <p>Other standard containers provide iterators as well. And, where they provide similar
    capabilities, the syntax is the same. Given a <pf>std::list</pf> called <pf>myList</pf>, we can get an iterator
    to the start of the list using <pf>myList.begin()</pf> and one past the end using <pf>myList.end()</pf>. However, not all
    iterator types provide the same capabilities. </p>

  <p>For example, in containers like lists, we can't jump forward or backward multiple items at a
    time the way we can with a vector iterator. Instead, we can only move an iterator forward one
    element at a time using the preincrement operator (<pf>++it</pf>) or backwards one element at a time
    using the predecrement operator (<pf>--it</pf>). This means that to get to the 3rd element in a list,
    we would need to start at <pf>myList.begin()</pf> and then do <pf>++</pf> two times to move forward to the 3rd
    element. </p>



    <figure>
      <caption>In a list <pf>begin()</pf> still gives an iterator to the first element and <pf>end()</pf> to one past the last element. But an iterator can only move forward or backward one element at a time. Given where <pf>it</pf> is, there is no way to jump directly to the 4th element.
      </caption>
      <image source="images/practical-programming/list-it.svg" width="80%">
        <shortdescription>A list with various iterators shown. The iterator "it" points to the 2nd element.</shortdescription>
      </image>
    </figure>


  <p>The type of a list iterator is <code>list&lt;T&gt;::iterator</code>, where <code>T</code> is the
    type of elements in the list. So for a <pf>list&lt;string&gt;</pf>, the iterator type would be <pf>
    list&lt;string&gt;::iterator</pf>. </p>

  <p>To access the element that an iterator points to, we use the dereference operator (<pf>*it</pf>).
    This gives us access to the element the iterator is pointing at. We can either read that value or assign to
  the element.</p>

  <insight>
    <p>The syntax <pf>*it</pf> looks just like the syntax for dereferencing a pointer in C++. The
      iterator is not a pointer, but it acts like one in many ways.</p>
  </insight>

  <p>This program demonstrates how to use an iterator to access the third element in a list. It also
    includes some illegal attempts to access elements by position. You can try uncommenting those
    lines to see that they do not compile.</p>

  <listing>
    <program label="practical-programming_associative-limitations-1"
             interactive="activecode"
             line-numbers="yes">
<xi:include href="../../programs/practical-programming/associative-limitations-1.cpp" parse="text"/>
    </program>
  </listing>

  <exercise label="practical-programming_associative-limitations-exercise-1">
    <statement>
      <p>Given an iterartor named <pf>myIt</pf>, how do you:</p>
      <p>Advance the iterator to the next item? <fillin mode="string"
                answer="++myIt"/></p>
      <p>Access the element the iterator points to? <fillin mode="string"
                answer="*myIt"/></p>
    </statement>
    <evaluation>
      <evaluate>
        <test correct="yes">
          <strcmp>\+\+myIt</strcmp>
        </test>
        <test>
          <strcmp>myIt\+\+</strcmp>
          <feedback>You should use the preincrement operator, not the postincrement</feedback>
        </test>
        <test>
          <strcmp>myIt\s*\+\s*1</strcmp>
          <feedback>That may work for some iterator types, but is not the preferred way to advance
            an iterator one element.</feedback>
        </test>
      </evaluate>
      <evaluate>
        <test correct="yes">
          <strcmp>\*myIt</strcmp>
        </test>
      </evaluate>
    </evaluation>
  </exercise>
</section>