<section xml:id="practical-programming_auto"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Iterator Based Loops and Auto</title>

  <p>At the end of the previous section, we saw how to use an iterator to traverse a list step by step.
    If we want to process all the elements in a container, we can use a loop that uses an iterator to move through the collection one element at a time:</p>

    <listing>
  <program line-numbers="yes">
  <![CDATA[ 
    for(list<string>::iterator it = fruit.begin(); 
        it != fruit.end(); 
        ++it
        ) {
        string currentValue = *it;
        cout << currentValue << " ";
    }
  ]]>
  </program>
  </listing>

  <p>The for loop is intentionally split over 3 lines to clearly show the initialization, condition, and increment parts of the loop.
    <ul>
      <li>On the first line, we initialize an iterator to the beginning of the list.</li>
      <li>On the second line, we specify the loop continuation condition, which checks if the iterator has reached the end of the list.</li>
      <li>On the third line, we increment the iterator to point to the next element in the list.</li>
    </ul>
    <p>Inside the loop, whenever we want to access the element the iterator points to, we use the dereference operator <pf>*</pf>.</p>
  </p>

    <p>
    We created an iterator variable by explicitly specifying its type, which can be a bit cumbersome. Here is the code we used to create an iterator for a set of strings:
  </p>

  <p>The syntax for the type of the iterator is a bit cumbersome: <pf>list&lt;string>::iterator</pf>. There is no such thing as <q>just an iterator</q>. Every iterator is tied to a specific container type. And so, we must specify the type of the container the iterator is associated with. This can get especially long and unwieldy when working with more complex containers like a list of multi-dimensional vectors.</p>

  <program line-numbers="yes" >
  <![CDATA[
    // A list of 2D grids (each grid is a vector of vector of ints)
    list<vector<vector<int>>> gridList;
    // An explicit iterator type for the gridList
    list<vector<vector<int>>>::iterator it = gridList.begin();
  ]]>
  </program>

  <p>
    We could use a typedef to make this less wordy. Something like this would help:
  </p>

<program line-numbers="yes" highlight-lines="2">
  <![CDATA[
    // Define a type alias for the iterator type
    typedef list<vector<vector<int>>>::iterator GridListIterator;
    // A list of 2D grids (each grid is a vector of vector of ints)
    list<vector<vector<int>>> gridList;
    // Now use the type alias to declare the iterator
    GridListIterator it = gridList.begin();
  ]]>
</program>

  <p>
    But C++ provides another solution: the <pf>auto</pf> keyword. When we use <pf>auto</pf> to declare a variable, the compiler automatically deduces the type of the variable based on the expression used to initialize it.
  </p>

  <program line-numbers="yes" highlight-lines="4">
  <![CDATA[
    // A list of 2D grids (each grid is a vector of vector of ints)
    list<vector<vector<int>>> gridList;
    // Compiler will examine the right side to determine the type of 'it'
    auto it = gridList.begin();
  ]]>
  </program>

  <p>
    The type of <pf>it</pf> will be set to the return type of <pf>gridList.begin()</pf>. In this case, that will be a <pf>list&lt;vector&lt;vector&lt;int>>::iterator</pf>. This allows us to avoid writing out the full type name, making the code cleaner and easier to read. It is hopefully clear to any C++ programmer that <pf>it</pf> is <q>an iterator over the gridList</q>.
  </p>

  <note>
    <p>
      The <pf>auto</pf> keyword can be used to declare any variable, not just iterators. You could use it to declare an integer like <pf>auto x = 5;</pf>.
    </p>
    <p>
      Once the type is deduced, it is fixed for that variable. So if you write <pf>auto x = 5;</pf>, then <pf>x</pf> is an integer and you cannot later assign a string to <pf>x</pf>.
    </p>
    <p>
      We have intentionally not used <pf>auto</pf> yet, because it is important to clearly understand data types before relying on type deduction. And using auto for everything can make code harder to read even for experienced programmers. <pf>auto</pf> should only be used when it improves code clarity or improves flexibility.
    </p>
  </note>

  <p>
    This means our loop can be rewritten using <pf>auto</pf> to declare the iterator to make it less wordy:
  </p>

  <listing xml:id="practical-programming_auto-1-listing">
    <program label="practical-programming_auto-1" interactive="activecode"
             line-numbers="yes" highlight-lines="" >
<xi:include href="../../programs/practical-programming/auto-1.cpp" parse="text"/>
    </program>
  </listing>

  <p>
    Not only does this make the code shorter, it also makes it more flexible. If we later decide to change the type of <pf>fruit</pf> from a <pf>list&lt;string></pf> to a <pf>vector&lt;string></pf>, we do not have to change the loop code at all. The type of <pf>it</pf> will automatically adjust to be the correct iterator type for whatever container type <pf>fruit</pf> is.
  </p>

  <p>
    Both a list and a vector support <pf>begin()</pf> and <pf>end()</pf> methods that return iterators that represent the start and end of the collection. And the different iterators both know how to move forward when told to do <pf>++it</pf> and access the current item when told to do <pf>*it</pf>. So the same loop logic works for both containers.
  </p>

  <activity>
  <p>Try changing the type of the container in <xref ref="practical-programming_auto-1-listing"/> to a vector. Change line 9 to declare a <pf>vector&lt;string></pf> instead of the <pf>set&lt;string></pf>. Then run the code again.</p>
  </activity>

  <insight>
    <p>Iterators provide a powerful abstraction that allows us to work with different types of containers in a uniform way. They enable algorithms to operate on a wide variety of data structures without needing to know the details of how those structures store their elements.</p>
  </insight>

  <p>
    We can also write a range based for loop using <pf>auto</pf> to simplify the syntax even further:
  </p>

  <listing>
  <program line-numbers="yes">
  <![CDATA[ 
    for(const auto& currentValue : fruit) {
        cout << currentValue << " ";
    }
  ]]>
  </program>
  </listing>

  <p>A range-based for loop is essentially syntactic sugar for an iterator-based loop. The compiler will translate it into something like the iterator loop we wrote earlier.</p>

  <exercise label="practical-programming_auto-exercise-1">
    <statement>
      <p>Arrange the blocks to set up an iterator based for loop over the elements in a container (we don't know/care what type) named <pf>container</pf>.</p>
    </statement>
    <blocks layout="horizontal">
      <block><c>for (</c></block>
      <block><c>auto</c></block>
      <block><c>it = </c></block>
      <block><c>=</c></block>
      <block><c>container.begin();</c></block>
      <block><c>it !=</c></block>
      <block><c>container.end();</c></block>
      <block><c>++it</c></block>
      <block><c>) {...</c></block>
      </blocks> 
  </exercise>

  <exercise label="practical-programming_auto-exercise-2">
    <statement>
      <p>What is the primary benefit of using the <pf>auto</pf> keyword when declaring an iterator?</p>
    </statement>
    <choices>
      <choice correct="yes">
        <statement>It makes the code more flexible.</statement>
      </choice>
      <choice>
        <statement>It makes the iterator run faster.</statement>
      </choice>
      <choice>
        <statement>It lets us type less.</statement>
      </choice>
    </choices>
  </exercise>

</section>