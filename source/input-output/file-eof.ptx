<section xml:id="input-output_file-eof"
         xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>End of File</title>

    <p>What if you do not know how many tokens there are to read?</p>
    
    <p>In that case we can keep reading until we encounter the end of the file. One way to detect if we have reached the end of the file is to just wait for an error. Trying to read another token once reach the end will produce an error! But we can also use the <pf>.eof()</pf> method to ask <q>are we at the End Of File yet?</q>. It returns <pf>true</pf> if the end has been reached. So <pf>!streamName.eof()</pf> checks <q>is there more to read?</q></p>

  <listing>
  <program label="input-output_file-eof-program-1" add-files="datafile-numbers"  interactive="activecode">
<xi:include href="../../programs/input-output/file-input-eof-1.cpp" parse="text"/>
</program>
  </listing>

  <p>You may notice one extra line of output. 60 is printed twice even though the file just has <c>10 20 30 40 50 60</c>. Why is this?</p>
  
  <p>The datafile has a newline character at the end of each line. It looks like this:</p>

  <pre>
    10 20 30(newline)
    40 50 60(newline)
    (eof)
  </pre>

  <p>So when we read the 60, the <pf>>></pf> operator gets that token, sees the newline, and stops. We have not yet hit the end of file marker! So the loop does not stop.
    we then try to read in a 7th value, that fails, and so the variable keeps its existing value of 60.</p>

  <p>Our code would work if the file looked like this:</p>

  <pre>
    10 20 30(newline)
    40 50 60(eof)
  </pre>

  <p>In that case, after reading the 60 we would have reached the end of file marker.</p>

  <p>To handle either case, we can just check for an error after reading in our data. Once we get past the 60, doing <pf>inFile >> number</pf> will fail if there is no more data to read. So if we have a failure, it might just mean we reached the end of the file. (Of course it could be some other issue. If we wanted to differentiate between the two we would have to check both <pf>inFile.eof()</pf> and <pf>inFile.fail()</pf>). This version uses that strategy:</p>

  <listing>
  <program label="input-output_file-eof-program-1b" add-files="datafile-numbers"  interactive="activecode">
<xi:include href="../../programs/input-output/file-input-eof-1b.cpp" parse="text"/>
</program>
  </listing>

  <insight><p>It is a good idea to check for errors after attempting to read data anyway. So <pf>inFile.fail()</pf> is both handling a possible blank line at the end of the file and it will handle any other read errors (like trying to read <pf>"cat"</pf> as an integer).</p></insight>

  <exercise label="input-output_file-eof-ex-1">
    <statement>
      <p>The <pf>ifstream</pf> member function <fillin mode="string"
                case="insensitive"
                answer="^(\\.)?eof(\\(\\))?"/>
        detects if the end of the file has been reached. </p>
    </statement>
    <evaluation>
      <evaluate>
        <test>
          <strcmp use-answer="yes"/>
        </test>
      </evaluate>
    </evaluation>
  </exercise>

</section>